<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>树 on Freeze&#39;s Blogs</title>
    <link>https://freeze.org.cn/docs/Graph/Tree/</link>
    <description>Recent content in 树 on Freeze&#39;s Blogs</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://freeze.org.cn/docs/Graph/Tree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>简介</title>
      <link>https://freeze.org.cn/docs/Graph/Tree/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Graph/Tree/intro/</guid>
      <description>树的定义 $  树有多种等价的定义方式：
  连通且无环的无向图；
  有 $n$ 个节点和 $n-1$ 条边的无向图；
  任意两个顶点间只有一条路径的无向图。
  图论中的树看起来更像现实中倒悬的树：
树的节点存在「父子关系」。以上图为例：
  有连边的两个节点中，上节点为下节点的父节点。如节点 $2$ 是节点 $5$ 的父节点；
  有连边的两个节点中，下节点为上节点的子节点，如节点 $5$ 是节点 $2$ 的子节点；
  没有父节点的节点为根节点，如节点 $1$；
  没有子节点的节点为叶节点，如节点 $5,6,3,8,9$。
  有根树和无根树 $  有根树必须明确根节点，而无根树的任意节点都可以是根节点。下面的左图和右图是同一棵无根树：
子树 $  将节点 $i$ 和其父节点断开，分裂出的以 $i$ 为根的新树，称作节点 $i$ 的子树。如下图，红色部分为节点 $3$ 的子树。
层和深度 $  定义根节点在第 $1$ 层，子节点层数 $=$ 父节点层数 $+1$：</description>
    </item>
    
    <item>
      <title>树的遍历</title>
      <link>https://freeze.org.cn/docs/Graph/Tree/traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Graph/Tree/traversal/</guid>
      <description>简介 $  递归访问树中所有节点的过程叫做树的遍历。本章介绍二叉树的 $3$ 种遍历方式。
前序遍历 $  先访问根节点，再遍历左子树，最后遍历右子树。上图的前序遍历顺序为 $1→2→4→5→3$。
void dfs(int u) { // 打印以 u 为根的树的遍历顺序  if(!u) return; cout &amp;lt;&amp;lt; u &amp;lt;&amp;lt; endl; dfs(l[u]); // l[u] 表示 u 的左子节点  dfs(r[u]); // r[u] 表示 u 的右子节点 } 中序遍历 $  先遍历左子树，再访问根节点，最后遍历右子树。上图的中序遍历顺序为 $4→2→5→1→3$。
void dfs(int u) { if(!u) return; dfs(l[u]); cout &amp;lt;&amp;lt; u &amp;lt;&amp;lt; endl; dfs(r[u]); } 后序遍历 $  先遍历左子树，再遍历右子树，最后访问根节点。上图的后序遍历顺序为 $4→5→2→3→1$。
void dfs(int u) { if(!</description>
    </item>
    
    <item>
      <title>最近公共祖先</title>
      <link>https://freeze.org.cn/docs/Graph/Tree/LCA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Graph/Tree/LCA/</guid>
      <description>简介 $  节点 $p$ 和 $q$ 的最近公共祖先（节点 $s$）是 $p$ 到 $q$ 最短路径中深度最浅的节点：
基本原理 $    从 $p$ 节点开始，不断往父节点移动，直到遇到根节点。标记运动路径中经过的节点；
  从 $q$ 节点开始，不断往父节点移动，直到遇到的节点被标记过。该节点是 $p$ 和 $q$ 的最近公共祖先。
  时间复杂度：$O(n)$。
int fa[]; bool mark[]; /* fa[i] : 节点 i 的父节点，fa[根节点] = 0 mark[i] : 节点 i 是否被标记 */ int LCA(int p, int q) { // 返回节点 p 和 q 的最近公共祖先  memset(mark, false, sizeof mark); while(p) mark[p] = true, p = fa[p]; while(!</description>
    </item>
    
    <item>
      <title>最小生成树</title>
      <link>https://freeze.org.cn/docs/Graph/Tree/MST/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Graph/Tree/MST/</guid>
      <description>简介 $   无向图 $G$ 的生成树同时满足以下性质：
  包含 $G$ 中的所有节点；
  任意两个节点都 连通；
  具有树的所有性质。
  下图的 $b$ 和 $c$ 皆为 $a$ 的生成树。
最小生成树是所有生成树中边权和最小的树。$n$ 个节点的无向图中，最小生成树有 $n-1$ 条边。
Kruskal 算法 $  Kruskal 算法是一种贪心算法。
  将 $m$ 条边按照边权升序排序；
  从小到大枚举边，若此边的两个顶点未连通，则在树中加入此边，并连通两个顶点。重复直到共加入 $n-1$ 条边。
  使用 并查集判断和维护两个顶点是否连通。
时间复杂度为 $O(m\log{m})$，适用于稀疏图。
int n, m, fa[]; struct edge { int x, y, len; } g[]; bool cmp(edge x, edge y) { return x.</description>
    </item>
    
  </channel>
</rss>
