'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/Basics/Search/bfs/',title:"BFS（广搜）",section:"搜索算法",content:"简介 $  广度优先搜索（Breadth First Search，简称 BFS）按照层次顺序查找节点，如下图：\n\r  访问节点 0（根节点）；\n  访问节点 0 的所有子结点（结点 1、2）；\n  访问节点 1、2 的所有子结点（结点 3、4、5）；\n$\\cdots \\ \\cdots$\n  重复访问子结点的操作，直到访问到目标节点。\n基本原理 $    定义一个队列，用于存放节点编号；\n  将根节点编号插入队尾（入队）；\n  将队头的所有子节点入队，移除队头元素（出队），重复直到队列为空。\n  Warning\n为了避免重复访问同一节点，已经进过队列的结点不能再次入队。\n bool vis[]; // vis[i] 代表节点 i 是否进过队列  void bfs(int s, int e) { // 在根节点为 s 的图中找到节点 e  memset(vis, false, sizeof vis); queue\u0026lt;int\u0026gt; Q; Q.push(s); // 根节点入队  while(!Q.empty()) { int top = Q.top(); Q.pop(); // 出队  if(top == e) return; // 找到结点 e  for(int i = top 的所有子节点编号) if(!vis[i]) // 如果没有进过队列  Q.push(i), vis[i] = true; // 入队  } } 节点层数 $  求任意节点所在的层数（深度）。\n 子节点层数 $=$ 父节点层数 $+$ $1$。  struct Node { int id, step; // id 为节点编号，step 为层数 }; bool vis[]; int bfs(int s, int e) { // 在根节点为 s 的图中，返回节点 e 的层数  memset(vis, false, sizeof vis); queue\u0026lt;Node\u0026gt; Q; Q.push(Node{s, 1}); while(!Q.empty()) { Node top = Q.top(); Q.pop(); if(top.id == e) return top.step; for(int i = top 的所有子节点编号) if(!vis[i]) { Q.push(Node{i, top.step + 1}); // 子节点层数 = 父节点层数 + 1  vis[i] = true; } } } "}),a.add({id:1,href:'/docs/String/hash/',title:"哈希函数",section:"字符串",content:"简介 $  哈希函数 $getHash()$ 能够将字符串转化成整数，并保证字符串不同，对应的整数也不同。该整数称为哈希值。这样，判断两个字符串是否相等，就只要判断它们的哈希值是否相等。\n基本原理 $  假设所有字符串中只包含小写字符 $a\\sim z$。以字符串 $fantasy$ 为例：\n  将字符 $a\\sim z$ 替换为数字 $1\\sim 26$，得到一个数列。如 $fantasy→[6,1,14,20,1,19,25]$。\n  将该数列看作一个 $27$ 进制数（逢 $27$ 进一）。\n  $$getHash(fantasy)=6·27^6+1·27^5+14·27^4+\\cdots+25·27^0$$\n按此方法设计的哈希函数，可保证不同字符串的哈希值必不同。但字符串长度过长时，哈希值会超出 long long 的范围。\n滚动哈希 $  为解决一般哈希函数适用范围有限的问题，采用滚动哈希方法。\n选取两个合适的质数 $b,p$，将字符串看作 $b$ 进制数（$b\u0026gt;$ 字符种数）。则：\n$$ getHash(fantasy)=(6·b^6+1·b^5+14·b^4+\\cdots+25·b^0)%p $$\n按此方法设计的哈希函数，不同字符串的哈希值相同的概率较小，且哈希值不会超出 long long 的范围。时间复杂度为 $O(n)$。\ntypedef long long LL; const LL b = 29, p = 10000019; LL getHash(string str) { // 返回 str 的哈希值  LL h = 0; for(int i = 0; i \u0026lt; str.size(); i ++) h = (h * b + str[i] - \u0026#39;a\u0026#39;) % p; return h; } 哈希冲突 $  使用 滚动哈希 时，有概率会使不同字符串的哈希值相同。该现象称为哈希冲突。\n一种降低哈希冲突概率的可靠方法是双哈希：使用两组不同的质数 $b_1,p_1$ 和 $b_2,p_2$，分别计算哈希值。只有两个哈希值分别相同，才能判定字符串的匹配。\ntypedef long long LL; const LL b_1 = 29, p_1 = 10000019; const LL b_2 = 31, p_2 = 10000079; LL getHash_1(string str) { LL h = 0; for(int i = 0; i \u0026lt; str.size(); i ++) h = (h * b_1 + str[i] - \u0026#39;a\u0026#39;) % p_1; return h; } LL getHash_2(string str) { LL h = 0; for(int i = 0; i \u0026lt; str.size(); i ++) h = (h * b_2 + str[i] - \u0026#39;a\u0026#39;) % p_2; return h; } bool cmp(string s1, string s2) { // 比较 s1 和 s2 的哈希值是否相同  return getHash_1(s1) == getHash_1(s2) \u0026amp;\u0026amp; getHash_2(s1) == getHash_2(s2); } "}),a.add({id:2,href:'/docs/DP/intro/',title:"简介",section:"动态规划",content:"简介 $  动态规划（DP） 是「打表」的最高境界，原理和考试时查草稿差不多。\n假如一道填空题需要求 $1024×768$，正常学生会在草稿纸上计算出它的值 $=768432$。\n\r此时某道应用题中再次出现了 $1024×768$：\n\r部分学生会在打过的草稿里找到 $1024×768=768432$，直接抄进答题卡，省得再计算。更专业的学生会把草稿打成表格，方便查表和检验。\n动态规划将「草稿纸」的参考性利用到极致，极大提高解题效率。\n基本原理 $  Info\n斐波那契数列是形如 $1, 1, 2, 3, 5, 8, \\cdots$ 的数列。求数列的第 $n$ 项。\n $f[n]$ 表示数列的第 $n$ 项，则：\n\r$$\rf[n]=\\left\\{\\begin{aligned}\r\u0026 1, n=1, 2\\\\\r\u0026 f[n-1]+f[n-2], n≥3\r\\end{aligned}\\right.\r$$\r\r先把特殊的 $f[1]=f[2]=1$ 填进表：\n   $f[1]$ $f[2]$     $1$ $1$    根据公式计算 $f[3]$ 时，需要用到 $f[1]$ 和 $f[2]$。在表中查找它们的值，代入计算：\n$$ f[3]=f[1]+f[2]=1+1=2 $$\n然后将 $f[3]$ 也填进表：\n   $f[1]$ $f[2]$ $\\color{red}{f[3]}$     $1$ $1$ $\\color{red}{2}$    重复查表 $-$ 计算 $-$ 填表步骤，直到算出 $f[n]$：\n   $f[1]$ $f[2]$ $f[3]$ $f[4]$ $f[5]$ $f[6]$ $f[7]$ $\\cdots$ $f[n]$     $1$ $1$ $2$ $3$ $5$ $8$ $11$ $\\cdots$     时间复杂度为 $O(n)$。\nint f[]; f[1] = f[2] = 1; for(int i = 3; i \u0026lt;= n; i ++) f[i] = f[i - 1] + f[i - 2]; 专业术语 $  问题和子问题 $  打个比方，求 $f[n]$ 是 （主）问题，则求 $f[n-1]$ 和 $f[n-2]$ 就是该问题的子问题。\n求主问题时，它的子问题必须先被填进表。例如求 $f[n]$ 时，$f[n-1]$ 和 $f[n-2]$ 必须先被填进表。\n状态转移方程 $  状态转移方程用于表示问题和子问题之间的关系：\n\r$$\rf[n]=\\left\\{\\begin{aligned}\r\u0026 1, n=1, 2\\\\\r\u0026 f[n-1]+f[n-2], n≥3\r\\end{aligned}\\right.\r$$\r\r初始、边界条件 $  初始条件：$f[1]=f[2]=1$。\n边界条件：$f[n]$ 被求出。\n动态规划从初始条件出发，一直填表计算到边界条件才结束。\n"}),a.add({id:3,href:'/docs/DS/intro/',title:"简介",section:"数据结构",content:"概念 $  数据结构是计算机储存、组织数据的方式，分为逻辑结构和物理结构。\n逻辑结构 $  数据元素之间的逻辑关系，分为以下四种：\n1. 线性结构 $  线性结构用于将元素按照某种顺序排列成「一条线」。\n\r2. 集合结构 $  集合结构用于分类元素，同类元素置于同个集合。如下图，$2,4,5,8,\\textbf{♂}$ 为同类元素，$1,3,6,7$ 为同类元素。\n\r3. 树形结构 $  树形结构的元素存在「一对多」的层次关系，适用于描述「上下级」关系，在 图论中有详细介绍。\n\r4. 图形结构 $  图形结构的元素存在「多对多」的关系，适用于描述「城市道路连通」关系，在 图论中有详细介绍。\n\r物理结构 $  元素在储存器中的储存方式，分为以下两种：\n1. 顺序结构 $  我们熟知的「数组」就是顺序结构，将元素存于一段连续内存中。\n顺序结构具有以下性质：\n  支持随机访问元素；\n  不支持插入元素。\n  相当于食堂打饭排队，大家都按顺序排好，每个人占一小段空间，谁也不插队。\n\r2. 链式结构 $  链式结构把元素存于任意内存单元（不一定连续），用指针存放关联元素的地址。\n链式机构具有以下性质：\n  不支持随机访问元素；\n  支持插入元素。\n  事实上食堂总会有人插队，相当于在两个元素之间插入一个元素。\n"}),a.add({id:4,href:'/docs/Graph/intro/',title:"简介",section:"图论",content:"图的定义 $  图（Graph）由若干顶点和边组成。用大写字母 $G$ 表示图，$V$ 表示顶点集合，$E$ 表示边集合，记作 $G=(V,E)$。\n 图是描述实际问题的工具。如进行城市道规划时，可将每个城市视作顶点，连接城市的道路视作边。\n有向图和无向图 $    如果图的每条边都规定起点和终点，则图被称作有向图；\n  相反，边没有方向（可以理解为双向）的图称为无向图（双向图）。\n   边权和点权 $  为解决实际问题，引入边权和点权的概念：\n  边权及边的长度。解决最短路径问题时，将城市视作顶点，城市之间的道路长度视作边权；\n  点权即点的大小。解决最小收费问题时，将收费站视作顶点，收费站之间的道路视作边，通过收费站支付的费用视作点权。\n  度数 $  若图中有 $d$ 条边与节点 $i$ 相连，则节点 $i$ 的度数为 $d$（即节点的连边个数）。如下图，节点 $1$ 的度为 $5$：\n   若有向图中有 $d$ 条边的终点是节点 $i$，则节点 $i$ 的入度为 $d$（即节点的入边个数）；\n  若有向图中有 $d$ 条边的起点是节点 $i$，则节点 $i$ 的出度为 $d$（即节点的出边个数）；\n  子图 $  图 $G$ 的子图 $H$ 满足以下条件：\n  $G$ 中包含 $H$ 的所有节点和边；\n  $G$ 和 $H$ 同时为无向图或有向图。\n  即 $G=(V,E),H=(V',E'),V'\\in V,E'\\in E$。如下图，$H$ 是 $G$ 的子图：\n 路径和连通 $  从节点 $i$ 走到节点 $j$，经过的边的序列为 $i$ 到 $j$ 的路径。路径的长度为经过边的边权和。\n如下图，节点 $1$ 到 $6$ 的一条路径为 $1-4-5-6$。\n 若两个节点之间存在路径，则称它们连通。\n回路（环） $  若图中存在起点和终点相同的路径，则此路径称作回路（环）。\n完全图和连通图 $    若无向图 $G$ 的任意两个节点之间都有连边，则 $G$ 称为完全图。\n$n$ 个结点的完全图有 $\\displaystyle\\frac{1}{2}n(n-1)$ 条边；\n  若无向图 $G$ 的任意两个节点都连通，则 $G$ 称为连通图。\n$n$ 个结点的连通图至少有 $n-1$ 条边。\n  强连通分量 $    若有向图 $G$ 的任意两个节点都连通，则 $G$ 称为强连通图；\n  若有向图 $G$ 的子图 $H$ 是强连通图，则 $H$ 称为 $G$ 的强连通分量。\n  "}),a.add({id:5,href:'/docs/Graph/Tree/intro/',title:"简介",section:"树",content:"树的定义 $  树有多种等价的定义方式：\n  连通且无环的无向图；\n  有 $n$ 个节点和 $n-1$ 条边的无向图；\n  任意两个顶点间只有一条路径的无向图。\n  图论中的树看起来更像现实中倒悬的树：\n\r树的节点存在「父子关系」。以上图为例：\n  有连边的两个节点中，上节点为下节点的父节点。如节点 $2$ 是节点 $5$ 的父节点；\n  有连边的两个节点中，下节点为上节点的子节点，如节点 $5$ 是节点 $2$ 的子节点；\n  没有父节点的节点为根节点，如节点 $1$；\n  没有子节点的节点为叶节点，如节点 $5,6,3,8,9$。\n  有根树和无根树 $  有根树必须明确根节点，而无根树的任意节点都可以是根节点。下面的左图和右图是同一棵无根树：\n\r子树 $  将节点 $i$ 和其父节点断开，分裂出的以 $i$ 为根的新树，称作节点 $i$ 的子树。如下图，红色部分为节点 $3$ 的子树。\n\r层和深度 $  定义根节点在第 $1$ 层，子节点层数 $=$ 父节点层数 $+1$：\n\r树的深度 $=$ 总层数。上图中树的深度为 $4$。\n二叉树 $  任意节点的子节点数量 $≤2$ 的树是二叉树：\n\r满二叉树 $  深度为 $k$ 的二叉树最多有 $2^k-1$ 个节点。节点最多的那棵树是满二叉树：\n\r满二叉树除最后一层外，其它层任意节点都有 $2$ 个子节点。\n完全二叉树 $  将满二叉树最后一层右边连续的若干节点删除，得到完全二叉树：\n\r满二叉树是一类特殊的二叉树。\n森林 $  多棵树组成的图为森林：\n\r"}),a.add({id:6,href:'/docs/Math/prime/',title:"质数",section:"数论",content:"定义 $    质数不能被 $1$ 和它本身之外的任何自然数整除，合数则相反。$1$ 既不是质数，也不是合数。\n  $\\pi(n)$ 表示 $n$ 以内的质数个数，$\\displaystyle\\pi(n)≈\\frac{n}{\\ln{n}}$ 。\n  第 $n$ 个质数的渐进估计为 $p(n)\\sim n\\ln{n}$。\n  质数的判定 $  判定非负整数 $n$ 是否为质数。\n试除法 $  若 $n$ 为合数，则 $n$ 一定有因子 $≤\\sqrt{n}$。\n判断 $n$ 能否整除 $[2,\\sqrt n]$ 中的整数，对于 $n=0$ 或 $1$ 需要特判。时间复杂度为 $O(\\sqrt n)$。\nbool isPrime(int n) { if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= sqrt(n); i ++) if(n % i == 0) return false; return true; } 质数筛法 $  求出 $n$ 以内的所有质数。\n朴素算法 $  对 $[2,n]$ 中的所有整数进行一次判断。时间复杂度为 $O(n\\sqrt{n})$。\nbool isPrime(int n) { if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= sqrt(n); i ++) if(n % i == 0) return false; return true; } vector\u0026lt;int\u0026gt; getPrime(int n) { vector\u0026lt;int\u0026gt; prime; for(int i = 2; i \u0026lt;= n; i ++) if(isPrime(i)) prime.push_back(i); return prime; } 埃氏筛法 $    标记 $2$ 的倍数（$4,6,8,\\cdots$）；\n  标记 $3$ 的倍数（$6,9,12,\\cdots$）；\n  $4$ 被标记过，不用标记 $4$ 的倍数；\n  标记 $5$ 的倍数；\n$\\cdots$\n  最后没被标记的数 $k$ 不能被 $[2,k-1]$ 中的任意整数整除，是质数。\n标记 $i$ 的倍数时，$2i,3i,\\cdots,(i-1)·i$ 都被比 $i$ 小的质数（$2,3,\\cdots$）标记过，因此只需从 $i^2$ 开始标记。时间复杂度为 $O(n log{log{n}})$。\nvector\u0026lt;int\u0026gt; getPrime(int n) { vector\u0026lt;int\u0026gt; prime; vector\u0026lt;bool\u0026gt; mark(n + 1); for(int i = 2; i \u0026lt;= n; i ++) { if(!mark[i]) { prime.push_back(i); for(int j = i; i * j \u0026lt;= n; j ++) mark[i * j] = true; } } return prime; } 线性筛法 $  在埃氏筛法中，有些合数会被重复标记，如 $12$ 会在 $i=2$ 和 $i=3$ 时被分别标记。让每个合数只被生成一次，就能避免重复标记。\n$prime[i]$：第 $i$ 个质数。\n$fact[i]$：$i$ 的最小质因子。\n标记 $i$ 的倍数时，枚举质数 $prime[j=0,1,2,\\cdots]$ 与 $i$ 相乘，构造合数：\n  若 $prime[j]≤fact[i]$，则 $prime[j]$ 为 $i·prime[j]$ 的最小质因子，标记该合数：$fact[i·prime[j]] = prime[j]$；\n  否则 $i·prime[j]$ 应该被另一个更小的质数生成，应跳出循环。\n  若 $fact[i]=0$，则 $i$ 没有被生成过，是质数，令 $fact[i] = i$ 并将 $i$ 加入质数容器。\n每个合数只会被自己的最小质因子生成一次，时间复杂度为 $O(n)$。\nvector\u0026lt;int\u0026gt; getPrime(int n) { vector\u0026lt;int\u0026gt; prime, fact(n + 1); for(int i = 2; i \u0026lt;= n; i ++) { if(!fact[i]) fact[i] = i, prime.push_back(i); for(int j = 0; i * prime[j] \u0026lt;= n; j ++) { if(prime[j] \u0026gt; fact[i]) break; fact[i * prime[j]] = prime[j]; } } return prime; } "}),a.add({id:7,href:'/docs/Basics/Search/dfs/',title:"DFS（深搜）",section:"搜索算法",content:"简介 $  深度优先搜索（Depth First Search，简称 DFS）在查找节点时，尽可能往更深处搜索，如下图：\n\r基本原理 $  DFS 算法在本质上是一种递归：\n  若当前结点为目标结点，直接返回；\n  递归搜索当前结点的每个子节点。\n  void dfs(int s, int e) { // 从节点 i 出发，查找结点 e  if(s == e) return; // 找到结点 e  for(int i = 结点 k 的子节点编号) dfs(i, e); // 搜索  return; // 回溯（此处可以省略） } "}),a.add({id:8,href:'/docs/String/hash-map/',title:"哈希表",section:"字符串",content:"简介 $  哈希表由 哈希函数 和 链表 组成，相当于「超级数组」。\n  数组的下标1可以是整数，浮点数，字符串等。\n  不用定义数组的长度。\n  引出问题 $  医院的排队系统需要记录每个病人对应的问诊顺序。此处假设每个病人的名称都是数字。\n   名称 $32$ $26$ $75$ $4$     问诊顺序 $1$ $2$ $3$ $4$    $p[i]$ 表示「名称为 $i$ 的病人的问诊顺序」。查询问诊顺序的时间复杂度为 $O(1)$。\nint p[]; void update(int i, int x) { // 记录病人 i 的问诊顺序为 x  p[i] = x; } int query(int i) { // 查询病人 i 的问诊顺序  return p[i]; } 然而总有某些病人不按套路取名。\n   名称 $114514$ $2333$ $45467333433233$ $404$     问诊顺序 $1$ $2$ $3$ $4$    要存储 $p[45467333433233]=3$，得先开一个长度为 $45467333433233$ 的数组。这明显不现实。\n构造 $  开一个如此丑陋的数组，会浪费超过 $99\\%$ 的空间。毕竟只用到了其中的四个元素。有没有办法使数组只占很少空间？\n设计哈希函数 $getHash()$，用 $p[getHash(i)]$ 表示病人 $i$ 的问诊顺序。对于本例，有：\n$$ getHash(i)=i\\%5 $$\n这样数组就只要开到 $p[5]$。但这么做会导致其它问题：病人 $114514$ 和病人 $404$ 的问诊顺序会同时存入 $p[4]$，因为 $getHash(114514)=getHash(404)=4$。于是我们可以将 $getHash()$ 相同的病人放在同一个链表里。\n\r查询病人 $i$ 的问诊顺序时，只需在 $getHash(i)$ 开头的链表中找到该病人。\n哈希函数 $  $getHash()$ 有多种构造方式：\n  取模法\n$$ getHash(x)=x\\%p $$\n其中 $p$ 为质数（如 $999997$）。\n  乘积取整法\n$$ getHash(x)=\\lfloor A·x\\rfloor\\%p $$\n其中 $p$ 为质数，$A$ 为区间 $(0,1)$ 中的无理数（如 $\\displaystyle\\frac{\\sqrt{5}-1}{2}$）。\n  数位分析法\n$$ getHash(s)=(s[0]+s[1]·b+s[2]·b^2+s[3]·b^3+\\cdots)\\%p $$\n其中 $s$ 为字符串，$b,p$ 为质数。详见 哈希函数。\n  模板 $  static struct hash_map { #define MOD (999997)  struct node { int val, next, key; } edge[MOD]; int head[MOD], cnt; int getHash(int x) { return x % MOD; } int\u0026amp; operator[](int key) { int h = getHash(key); for(int p = head[h]; p; p = edge[p].next) if(edge[p].key == key) return edge[p].val; edge[++ cnt] = (node){0, head[h], key}, head[h] = cnt; return edge[cnt].val; } hash_map() { cnt = 0; memset(head, 0, sizeof head); } }   中括号里的数称之为「下标」，例如 $a[14]$ 的下标为 $14$。 \u0026#x21a9;\u0026#xfe0e;\n   "}),a.add({id:9,href:'/docs/Math/factor/',title:"因数",section:"数论",content:"定义 $  若整数 $n%d=0$，则 $d$ 是 $n$ 的 因数，记为 $d|n$。\n算数基本定理 $  任意 $n\\in Z^{+}$ 都能唯一分解为有限个质数的乘积：\n$$ n=p_1^{c_1}×p_2^{c_2}×\u0026hellip;×p_m^{c_m} \\ , \\ p_i∈\\mathbb{P},c_i\\in Z^{+} $$\n欧几里得算法 $  最大公因数 $  如何求 $a$ 和 $b$ 的最大公因数？\n$gcd(a,b)$ 表示 $a$ 和 $b$ 的最大公因数。\n设 $a \u0026gt; b$，$gcd(a, b)=x$，则 $a|x, b|x,(a%b)|x$，\n$∴gcd(a,b)=gcd(b,a%b)(a \u0026gt; b \u0026gt; a%b)$。\n于是「求 $gcd(a,b)$」的问题被转化为「求 $gcd(b,a%b)$」这一范围更小的问题。当 $b=0$ 时，$a$ 即为最大公因数。\n时间复杂度为 $O(log{(a+b)})$。\nint gcd(a, b) { if(!b) return a; return gcd(b, a % b); } 最小公倍数 $  如何求 $a$ 和 $b$ 的最小公倍数？\n$lcm(a,b)$ 表示 $a$ 和 $b$ 的最小公倍数。\n设 $gcd(a,b)=x$，则有 $a = k_1x,$ $b=k_2x,$ $k_i \\in Z^{+}$，\n$\\displaystyle∴lcm(a,b)=k_1k_2x=\\frac{ab}{x}$，即 $\\displaystyle lcm(a,b)=\\frac{ab}{gcd(a,b)}$。\n时间复杂度和 $gcd$ 一致。\nint lcm(a, b) { return a * b / gcd(a, b); } 互质数 $  公因数只有 $1$ 的一对的整数是互质数。\nbool isCoprime(int a, int b) { return gcd(a, b) == 1; } 分解质因数 $  如何将 $n$ 分解为多个质数相乘的形式（见 算数基本定理）？\n试除法 $  判断 $n$ 能否整除 $[2,\\sqrt{n}]$ 中的所有整数 $i$，如果能，则从 $n$ 中除掉所有的因子 $i$，并记录因子 $i$ 的个数。时间复杂度为 $O(\\sqrt n)$。\n样例程序中，$vec[i].first$ 为 $n$ 的第 $i$ 个因数，$vec[i].second$ 为其指数。\nvector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; devide(int n) { vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; vec; for(int i = 2; i \u0026lt;= sqrt(n); i ++) { if(n % i == 0) { vec.push_back(make_pair(i, 0)); while(n % i == 0) n /= i, vec.back().second ++; } } if(n != 1) vec.push_back(make_pair(n, 1)); return vec; } 倍数法 $  如何求 $[1,n]$ 中所有整数的因数集合？\n用「试除法」很容易超时，此时考虑「倍数法」：\n$i$ 一定是 $i·j(j\\in Z^{+})$ 的因数。时间复杂度为 $O(nlog{n})$。\nvector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; factor(int n) { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; vec = vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;(n + 1); for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; i * j \u0026lt;= n; j ++) vec[i * j].push_back(i); return vec; } 欧拉函数 $  $n$ 的欧拉函数为 $[1,n]$ 中与 $n$ 互质的数的个数，记为 $\\phi(n)$。特别地，$\\phi(1)=1$。\n如何求 $[1,n]$ 中任意数的欧拉函数？\n如果 $p$ 是 $n$ 的质因子，则 $p$ 的所有倍数（$2p,3p,\\cdots,$ 共 $\\displaystyle\\frac{n}{p}$ 个）都不与 $n$ 互质。则可能与 $n$ 互质的数只剩 $\\displaystyle n·(1-\\frac{1}{p})$ 个。\n设 $n$ 的质因子为 $p_1,p_2,\\cdots,p_m$，根据乘法原理，有：\n$$ \\phi(n)=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_m})=n\\prod_{i=1}^{m}(1-\\frac{1}{p_i}) $$\n时间复杂度为 $O(\\sqrt{n})$。\nint phi(int n) { int ans = n; for(int i = 2; i \u0026lt;= sqrt(n); i ++) if(n % i == 0) { ans = ans / i * (i - 1); while(n % i == 0) n /= i; } if(n \u0026gt; 1) ans = ans / n * (n - 1); return ans; } 线性欧拉算法 $  如何求 $[1,n]$ 中所有数的欧拉函数集合？\n基于质数的线性筛法进行改写：\n若 $a,b$ 互质，则 $\\phi(ab)=\\phi(a) \\cdot \\phi(b)$。在线性筛法构造合数 $i \\cdot prime[j]$ 时，由于 $i$ 和 $prime[j]$ 互质，令 $phi[i × prime[j]]=phi[i] × phi[prime[j]]$ 。\n若 $phi[i] = 0$，则 $i$ 没有被标记过，是质数，令 $phi[i]=i-1$。\n当 $i%prime[j]=0$ 时，$i$ 和 $prime[j]$ 不互质，退出循环。\n时间复杂度为 $O(n)$。\nvector\u0026lt;int\u0026gt; phi(int n) { if(n == 1) return vector\u0026lt;int\u0026gt; {0, 1}; vector\u0026lt;int\u0026gt; prime, phi(n + 1); for(int i = 2; i \u0026lt;= n; i ++) { if(!phi[i]) phi[i] = i - 1, prime.push_back(i); for(int j = 0; i * prime[j] \u0026lt;= n; j ++) { if(i % prime[j] == 0) break; phi[i * prime[j]] = phi[i] * phi[prime[j]]; } } return phi; } "}),a.add({id:10,href:'/docs/Graph/store/',title:"图的存储",section:"图论",content:"直接存边 $  把每条边的起点、终点、长度存入结构体数组中。\nstruct node { int from, to, len; } edge[]; 也可以分成三个数组来存储。\nint from[], to[], len[]; 邻接矩阵 $  用二维数组 $g[ \\ ][ \\ ]$（邻接矩阵）存储边长。$g[i][j]$ 表示节点 $i$ 和 $j$ 之间的边的权值。\n缺点：不能存储重边；浪费空间。\n邻接表 $  把节点 $i$ 的所有相邻节点插入以 $head[i]$ 开头的 链表中（链表最后一个元素的 next 指向 0）。\nint top, head[]; struct Node { int val, len; int next; // 这里只需要用到单向链表 } edge[]; void insert(int u, int v, int len) { // 追加一条从 u 到 v 长度为 len 的边  edge[++ top] = Node{v, len, head[u]}; head[u] = top; } int path(int u, int v) { // 获取以 u, v 为端点的边的长度（没有边则返回 -1）  for(int p = head[u]; p; p = edge[p].next) if(edge[p].val == v) return edge[p].len; return -1; } 邻接表可以用 [STL Vector` 实现。\nstruct Node { int val, len; }; vector\u0026lt;Node\u0026gt; edge[]; void insert(int u, int v, int len) { edge[u].push_back(Node{v, len}); } int path(int u, int v) { for(int i = 0; i \u0026lt; edge[u].size(); i ++) if(edge[u][i].val == v) return edge[u][i].len; return -1; } "}),a.add({id:11,href:'/docs/DS/stack/',title:"栈",section:"数据结构",content:"简介 $  栈是一种「先进后出」的数据结构。类似于在桶中堆积物品，取物品时只能从顶端开始取，最先进桶的被压在最底下，最后被取出来。基本操作见 STL Stack。\n\r表达式计算 $  算术表达式分为三类（$op$ 为运算符，$A,B$ 为数字或表达式）：\n  中缀表达式：全国人民都在用的表达式，如「$5×(3+2)$」；\n  前缀表达式：形如「$op \\ \\textcolor{red}{A} \\ \\textcolor{blue}{B}$」，如「$× \\ \\textcolor{red}{5} \\ \\textcolor{blue}{+} \\ \\textcolor{blue}{3} \\ \\textcolor{blue}{2}$」；\n  后缀表达式：形如「$\\textcolor{red}{A} \\ \\textcolor{blue}{B} \\ op$」，如「$\\textcolor{red}{3} \\ \\textcolor{red}{2} \\ \\textcolor{red}{+} \\ \\textcolor{blue}{5} \\ ×$」。\n  计算前/后缀表达式时，先递归求出 $A,B$ 的值，二者再做 $op$ 运算。计算方案是唯一确定的，且不需要使用括号。计算后缀表达式的算法最容易设计。\n后缀表达式 $    定义一个栈，用于存放数；\n  逐一扫描后缀表达式中的元素：\n  若扫到一个数 $n$，则把 $n$ 入栈；\n  若扫到运算符 $op$ ，则弹出栈顶的两个元素，二者做 $op$ 计算。将计算结果入栈。\n    最终的栈顶元素就是计算结果。时间复杂度为 $O(n)$。\nbool isdigit(char ch) { // 判断是否为数字  return ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;; } bool isop(char ch) { // 判断是否为运算符  return ch == \u0026#39;+\u0026#39; || ch == \u0026#39;-\u0026#39; || ch == \u0026#39;*\u0026#39; || ch == \u0026#39;/\u0026#39; || ch == \u0026#39;^\u0026#39;; } double postfix_calc(string str) { stack\u0026lt;double\u0026gt; s; int i = 0; s = stack\u0026lt;double\u0026gt;(); while(i \u0026lt; str.size()) { if(isdigit(str[i])) { // 假定输入数据只包含整数  double x = 0; while(isdigit(str[i])) x = x * 10 + str[i ++] - \u0026#39;0\u0026#39;; s.push(x); continue; } else if(isop(str[i])) { double r = s.top(); s.pop(); double l = s.top(); s.pop(); double ans; switch(str[i]) { case \u0026#39;+\u0026#39; : ans = l + r; break; case \u0026#39;-\u0026#39; : ans = l - r; break; case \u0026#39;*\u0026#39; : ans = l * r; break; case \u0026#39;/\u0026#39; : ans = l / r; break; case \u0026#39;^\u0026#39; : ans = pow(l, r); break; } s.push(ans); } i ++; } return s.top(); } 中缀表达式 $  先将中缀表达式转换成 后缀表达式 再计算。\n  定义一个栈，用于存放运算符；\n  逐一扫描中缀表达式中的元素：\n  若扫到一个数 $n$，直接输出 $n$；\n  若扫到「左括号」，把左括号入栈；\n  若扫到「右括号」，重复取栈顶并输出，直到栈顶为左括号，再出栈左括号；\n  若扫到其它运算符 $op$，重复取栈顶并输出，直到栈顶的优先级大于 $op$，再把 $op$ 入栈。\n    运算符优先级越大，越晚出栈，因此可以将「左括号」的优先级视作最低，「右括号」的优先级视作最高。\n时间复杂度为 $O(n)$。\n   运算符 $($ $+/-$ $×/÷$ $\\wedge$ $)$     优先级 最低（0） 低（1） 中（2） 高（3） 最高（4）    int lev(char ch) { // 返回运算符对应的优先级  int level; switch(ch) { case \u0026#39;(\u0026#39; : level = 0; break; case \u0026#39;)\u0026#39; : level = 4; break; case \u0026#39;+\u0026#39; : level = 1; break; case \u0026#39;-\u0026#39; : level = 1; break; case \u0026#39;*\u0026#39; : level = 2; break; case \u0026#39;/\u0026#39; : level = 2; break; case \u0026#39;^\u0026#39; : level = 3; break; } return level; } double infix_calc(string str) { string data; stack\u0026lt;char\u0026gt; op; int i = 0; while(i \u0026lt; str.size()) { if(isdigit(str[i])) { while(isdigit(str[i])) data += str[i ++]; data += \u0026#39; \u0026#39;; // 数与数之间用空格区分  continue; } else if(isop(str[i])) { while(!op.empty() \u0026amp;\u0026amp; lev(op.top()) \u0026lt;= lev(str[i])) { if(op.top() != \u0026#39;(\u0026#39; \u0026amp;\u0026amp; op.top() != \u0026#39;)\u0026#39;) data += op.top(); op.pop(); } op.push(str[i]); } i ++; } while(!op.empty()) { // 输出栈内剩余元素  if(op.top() != \u0026#39;(\u0026#39; \u0026amp;\u0026amp; op.top() != \u0026#39;)\u0026#39;) data += op.top(); op.pop(); } return postfix_calc(data); } 单调栈 $  单调栈中的元素从栈底到栈顶满足单调性。\n插入元素 $  将元素 $x$ 入栈，同时维护栈的单调性。以单调递增栈为例：\n  从栈顶依次弹掉比 $x$ 大的元素，保证 $x≥$ 栈顶；\n  将 $x$ 入栈。\n  stack\u0026lt;int\u0026gt; s; void insert(int x) while(!s.empty() \u0026amp;\u0026amp; s.top() \u0026gt; x) s.pop(); s.push(x); } 应用 $  单调递增栈可以实现快速查询「左边第一个更小的元素」。例如 $A={1,2,5,4,3,6}$，$A_5=3$ 的左边第一个比它小的元素是 $A_2=2$。\n顺序扫描 $A$ ，将 $A_i$ 插入单调栈前，栈中比 $A_i$ 大的元素都被弹掉了，栈顶元素即为左边第一个比 $A_i$ 小的元素。\nstack\u0026lt;int\u0026gt; s; for(int i = 1; i \u0026lt;= n; i ++) { while(!s.empty() \u0026amp;\u0026amp; s.top() \u0026gt; a[i]) s.pop(); if(!s.empty()) cout \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; // 输出 a[i] 左边第一个更小的元素  else cout \u0026lt;\u0026lt; \u0026#34;none\u0026#34; \u0026lt;\u0026lt; endl; // 如果没有则输出 none  s.push(a[i]); } Info\n  求左边第一个更小的元素 $\u0026mdash;$ 顺序扫描 $+$ 单调递增栈。\n  求左边第一个更大的元素 $\u0026mdash;$ 顺序扫描 $+$ 单调递减栈。\n  求右边第一个更小的元素 $\u0026mdash;$ 倒序扫描 $+$ 单调递增栈。\n  求右边第一个更大的元素 $\u0026mdash;$ 倒序扫描 $+$ 单调递减栈。\n   "}),a.add({id:12,href:'/docs/Graph/Tree/traversal/',title:"树的遍历",section:"树",content:"简介 $  递归访问树中所有节点的过程叫做树的遍历。本章介绍二叉树的 $3$ 种遍历方式。\n\r前序遍历 $  先访问根节点，再遍历左子树，最后遍历右子树。上图的前序遍历顺序为 $1→2→4→5→3$。\nvoid dfs(int u) { // 打印以 u 为根的树的遍历顺序  if(!u) return; cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; endl; dfs(l[u]); // l[u] 表示 u 的左子节点  dfs(r[u]); // r[u] 表示 u 的右子节点 } 中序遍历 $  先遍历左子树，再访问根节点，最后遍历右子树。上图的中序遍历顺序为 $4→2→5→1→3$。\nvoid dfs(int u) { if(!u) return; dfs(l[u]); cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; endl; dfs(r[u]); } 后序遍历 $  先遍历左子树，再遍历右子树，最后访问根节点。上图的后序遍历顺序为 $4→5→2→3→1$。\nvoid dfs(int u) { if(!u) return; dfs(l[u]); dfs(r[u]); cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; endl; } 树的恢复 $  Warning\n该模块正在开发中 $\\cdots \\ \\cdots$\n "}),a.add({id:13,href:'/docs/DP/memo/',title:"记忆化搜索",section:"动态规划",content:"普通搜索 $  求 斐波那契数列 第 $i$ 项（$f[i]$）的深搜程序如下：\nint f(int x) { if(x \u0026lt;= 2) return 1; return f(x - 1) + f(x - 2); } 执行 $f(7)$ 的调用情况如下：\n\r随着 $n$ 的增大，$f(n)$ 的时间复杂度呈指数级增长。如果遇到大数据，你的程序就会：\n\r记忆化搜索 $  考虑开数组 $F[ \\ ]$ 保存计算结果，从而避免重复计算。\n  若 $f(x)$ 未被调用，算出 $f(x)$ 的结果，并存入 $F[\\text{x}]$；\n  若 $f(x)$ 已经被调用过，直接返回 $F[\\text{x}]$。\n  和 动态规划 中的填表思想如出一辙。\nint F[] = {0, 1, 1}; int f(int x) { if(F[x] != 0) return f[x]; // 如果 F[x] ≠ 0，则 f(x) 已经被调用过  return F[x] = f(x - 1) + f(x - 2); // 返回时保存 } 执行 $f(7)$ 的调用情况如下：\n\r记忆化搜索的效率和动态规划相当，设计难度低于动态规划。若难以判断计算顺序，则可以采用该算法。\n"}),a.add({id:14,href:'/docs/String/KMP/',title:"KMP 算法",section:"字符串",content:"简介 $  $KMP$ 算法并不能用来看毛片，它是一种字符串匹配算法。$KMP$ 是该算法的发明者 $Kruth$，$Morris$ 和 $Pratt$ 的名字缩写。\n\r引出问题 $  给定字符串 $A$（长度为 $m$）和 $B$（长度为 $n$），问 $A$ 中是否包含 $B$ ？\n\r$$\r\\begin{aligned}\rA\u0026=a \\ b \\ a \\ b \\ a \\ b \\ a \\ b \\ c\\\\\rB\u0026=a \\ b \\ a \\ b \\ c\r\\end{aligned}\r$$\r\r首先将 $A$ 和 $B$ 的左端对齐，发现 $\\textcolor{red}{a}$ 与 $\\textcolor{red}{c}$ 不匹配，于是将 $B$ 向右移一位。\n\r$$\r\\begin{aligned}\rA\u0026=\\color{green}a \\ b \\ a \\ b \\ \\color{red}a\\color{black} \\ b \\ a \\ b \\ c\\\\\rB\u0026=\\color{green}a \\ b \\ a \\ b \\ \\color{red}c\\\\\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA=\\color{lightgrey}a\\color{black} \\ \u0026b \\ a \\ b \\ a \\ b \\ a \\ b \\ c\\\\\r→B= \\ \u0026a \\ b \\ a \\ b \\ c\r\\end{aligned}\r$$\r\r重复右移 $B$，直到在 $A$ 中匹配出完整的 $B$。\n\r$$\r\\begin{aligned}\rA=\\color{lightgrey}a \\ \u0026\\color{black}b\\ \\ a \\ b \\ a \\ b \\ a \\ b \\ c\\\\\rB= \\ \u0026a \\ b \\ a \\ b \\ c\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA=\\color{lightgrey}a \\ b \\ \u0026\\color{black}a \\ b \\ a \\ b \\ a \\ b \\ c\\\\\r→B= \\ \u0026a \\ b \\ a \\ b \\ c\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA=\\color{lightgrey}a \\ b \\ a \\ \u0026\\color{black}b \\ a \\ b \\ a \\ b \\ c\\\\\r→B= \\ \u0026a\\ b \\ a \\ b \\ c\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA=\\color{lightgrey}a \\ b \\ a \\ b \\ \u0026\\color{black}\\color{green}a \\ b \\ a \\ b \\ c\\\\\r→B= \\ \u0026\\color{green}a \\ b \\ a \\ b \\ c\r\\end{aligned}\r$$\r\rbool match(string a, string b) { int m = a.size(), n = b.size(); int i = 0, j = 0; while(i \u0026lt; m) { while(j \u0026lt; n \u0026amp;\u0026amp; a[i] == b[j]) j ++; if(j == n) return true; i ++, j = 0; } return false; }    暴力算法（$\\textcolor{red}{×}$） $KMP$ 算法（$\\textcolor{green}{√}$）     $\\textcolor{red}{O(mn)}$ $\\textcolor{green}{O(m+n)}$    基本原理 $  其实，匹配到这一步时，$B$ 串可以直接向后移 $2$ 位。\n\r$$\r\\begin{aligned}\rA\u0026=\\color{green}a \\ b \\ a \\ b \\ \\color{red}a\\color{black} \\ b \\ a \\ b \\ c\\\\\rB\u0026=\\color{green}a \\ b \\ a \\ b \\ \\color{red}c\\\\\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA=\\color{lightgrey}a \\ b \\ \\color{black} \u0026a \\ b \\ a \\ b \\ a \\ b \\ c\\\\\r→B= \\ \u0026a \\ b \\ a \\ b \\ c\r\\end{aligned}\r$$\r\r为什么可以这么做呢？\n单独看 $B$ 串的绿色部分，容易发现它的前半段（前缀）和后半段（后缀）都是 $a \\ b$。\n\r$$\r\\begin{aligned}\rB= \\ \u0026\\color{green}a \\ b \\ a \\ b \\color{red} \\ c \\\\\r\u0026\\color{black}\\underset{前缀}{\\underline{a \\ b}}\\underset{后缀}{\\underline{a \\ b}}\r\\end{aligned}\r$$\r\r此时 $A$ 串和 $B$ 串的绿色部分是匹配的，上下两段也相等。\n\r$$\r\\begin{aligned}\rA\u0026=\\color{green}a \\ b \\ \\underline{a \\ b} \\ \\color{red}a\\color{black} \\ b \\ a \\ b \\ c\\\\\rB\u0026=\\color{green}a \\ b \\ \\underline{a \\ b} \\ \\color{red}c\\\\\r\\end{aligned}\r$$\r\r因而 $A$ 串和 $B$ 串的这两段也相等。\n\r$$\r\\begin{aligned}\rA\u0026=a \\ b \\ \\color{green}\\underline{a \\ b}\\color{black} \\ a \\ b \\ a \\ b \\ c\\\\\rB\u0026=\\color{green}\\underline{a \\ b}\\color{black} \\ a \\ b \\ c\\\\\r\\end{aligned}\r$$\r\r容易证明，若 $B$ 串只向右移 $1$ 位，肯定匹配不成。因此 $B$ 串至少需要向右移 $2$ 位。\n\r$$\r\\begin{aligned}\rA= a \\ \u0026b \\ \\underline{a \\ b} \\ a \\ b \\ a \\ b \\ c\\\\\r→B= \u0026\\underline{a \\ b} \\ a \\ b \\ c\\\\\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA= a \\ b \\ \u0026\\color{green}\\underline{a \\ b}\\color{black} \\ a \\ b \\ a \\ b \\ c\\\\\r→B= \u0026\\color{green}\\underline{a \\ b}\\color{black} \\ a \\ b \\ c\\\\\r\\end{aligned}\r$$\r\r下面一例中，$B$ 串在右移 $1\\sim 3$ 位时都匹配不成，因此至少向右移 $4$ 位，也就是一直右移到 $B$ 串的前缀和后缀对齐。\n\r$$\r\\begin{aligned}\rA= \\ \u0026\\color{green}s \\ e \\ d \\ c \\ s \\ e \\ d \\color{red}\\ c \\color{black} \\ s \\ e \\ d \\ s\\\\\rB= \\ \u0026\\color{green}s \\ e \\ d \\ c \\ s \\ e \\ d \\color{red}\\ s\\\\\r\u0026\\color{black} \\underset{前缀}{\\underline{s \\ e \\ d}} \\ c \\ \\underset{后缀}{\\underline{s \\ e \\ d}}\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA\u0026=s \\ e \\ d \\ c \\ \\color{green}\\underline{s \\ e \\ d}\\color{black} \\ c \\ s \\ e \\ d \\ s\\\\\rB\u0026=\\color{green}\\underline{s \\ e \\ d}\\color{black} \\ c \\ s \\ e \\ d \\ s\\\\\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA=s \\ e \\ d \\ c \\ \\underline{s \\ e \\ d} \\ c\u0026 \\ s \\ e \\ d \\ s\\\\\r→B=\\underline{s \\ e \\ d} \\ c \\ s \\ e \\ d\u0026 \\ s\\\\\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA=s \\ e \\ d \\ c \\ \\underline{s \\ e \\ d} \\ c \\ s\u0026 \\ e \\ d \\ s\\\\\r→B=\\underline{s \\ e \\ d} \\ c \\ s \\ e \\ d\u0026 \\ s\\\\\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA=s \\ e \\ d \\ c \\ \\underline{s \\ e \\ d} \\ c \\ s \\ e\u0026 \\ d \\ s\\\\\r→B=\\underline{s \\ e \\ d} \\ c \\ s \\ e \\ d\u0026 \\ s\\\\\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA=s \\ e \\ d \\ c \\ \\underline{\\color{green}s \\ e \\ d\\color{black}} \\ c \\ s \\ e \\ d\u0026 \\ s\\\\\r→B=\\underline{\\color{green}s \\ e \\ d\\color{black}} \\ c \\ s \\ e \\ d\u0026 \\ s\\\\\r\\end{aligned}\r$$\r\r如果没有前后两段相等的呢？如下面一例，右移 $B$ 串直到两段绿的完全错开。\n\r$$\r\\begin{aligned}\rA\u0026=\\color{green}a \\ b \\ c \\ d\\color{red} \\ a\\color{black} \\ b \\ c \\ d \\ f\\\\\rB\u0026=\\color{green}a \\ b \\ c \\ d\\color{red} \\ f\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA=\\color{green}a \\ b \\ c \\ d\\color{black} \\ \u0026a \\ b \\ c \\ d \\ f\\\\\r→B= \\ \u0026\\color{green}a \\ b \\ c \\ d\\color{black} \\ f\r\\end{aligned}\r$$\r\r$KMP$ 算法步骤总结：\n1 将 $A$ 串和 $B$ 串左端对齐。\n\r$$\r\\begin{aligned}\rA \u0026= \\pi\\pi\\pi\\pi\\pi\\pi\\pi\\pi\\pi\\pi\\pi\\pi\\\\\rB \u0026= \\pi\\pi\\pi\\pi\\pi\\pi\\pi\r\\end{aligned}\r$$\r\r2 从左往右比较字符，直到出现不匹配的情况。\n\r$$\r\\begin{aligned}\rA \u0026= \\color{green}\\pi\\pi\\pi\\pi\\pi\\color{red}\\pi\\color{black}\\pi\\pi\\pi\\pi\\pi\\pi\\\\\rB \u0026= \\color{green}\\pi\\pi\\pi\\pi\\pi\\color{red}\\pi\\color{black}\\pi\r\\end{aligned}\r$$\r\r3 在绿色子段中找出相同的前缀和后缀。\n\r$$\r\\begin{aligned}\rA \u0026= \\color{lightgreen}\\pi\\pi\\pi\\overset{\\color{black}后缀}{\\color{green}\\underline{\\pi\\pi}}\\color{black}\\pi\\pi\\pi\\pi\\pi\\pi\\pi\\\\\rB \u0026= \\underset{\\color{black}前缀}{\\color{green}\\underline{\\pi\\pi}}\\color{lightgreen}\\pi\\pi\\pi\\color{black}\\pi\\pi\r\\end{aligned}\r$$\r\r4 把 $B$ 串往右拉，直到前缀和后缀对齐，再从蓝色处继续向右比较。\n\r$$\r\\begin{aligned}\rA = \\pi\\pi\\pi\u0026\\color{green}\\underline{\\pi\\pi}\\color{black}\\pi\\pi\\pi\\pi\\pi\\pi\\pi\\\\\r→B = \u0026\\color{green}\\underline{\\pi\\pi}\\color{black}\\pi\\pi\\pi\\pi\\pi\r\\end{aligned}\r\\\\\r\\begin{aligned}\r\\\\\rA = \\pi\\pi\\pi\u0026\\color{green}\\underline{\\pi\\pi}\\overset{\\displaystyle\\color{black}↓}{\\color{blue}\\pi}\\color{black}\\pi\\pi\\pi\\pi\\pi\\pi\\\\\rB = \u0026\\color{green}\\underline{\\pi\\pi}\\underset{\\displaystyle\\color{black}↑}{\\color{blue}\\pi}\\color{black}\\pi\\pi\\pi\\pi\r\\end{aligned}\r$$\r\r 预处理 $  当务之急是，在不匹配时，从 $B$ 串的绿色子段中找出相同的前缀和后缀。\n下面一例中，$\\textcolor{green}{joxjo}$ 的前缀 $\\textcolor{green}{jo}$ 和后缀 $\\textcolor{green}{jo}$ 相同。$\\textcolor{green}{jo}$ 称为 $\\textcolor{green}{joxjo}$ 的「公共前后缀」。\n\r注意：公共前后缀不能和原字符串相等。即 $joxjo$ 的公共前后缀不能是 $joxjo$。\n$next[x]$：$B[0\\cdots x]$ 的最长公共前后缀的长度。\n   $x$ $B[0\\cdots x]$ 公共前后缀 $next[x]$     $0$ $j$  $0$   $1$ $jo$  $0$   $2$ $jox$  $0$   $3$ $\\underline{\\textcolor{red}{j}}ox\\underline{\\textcolor{red}{j}}$ $\\textcolor{red}{j}$ $1$   $4$ $\\underline{\\textcolor{red}{jo}}x\\underline{\\textcolor{red}{jo}}$ $\\textcolor{red}{jo}$ $2$   $5$ $\\underline{\\textcolor{red}{jox}}\\underline{\\textcolor{red}{jox}}$ $\\textcolor{red}{jox}$ $3$   $6$ $joxjoxx$  $0$   $7$ $joxjoxxx$  $0$    如何编程求出 $next[ \\ ]$ 数组？这里以字符串 $aabaabaaa$ 为例。\n对于任意字符串 $B$，$next[0]=0$。\n   $x$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$     $next[x]$ $\\textcolor{red}{0}$            使 $i$ 指向 $B[0]$，$j$ 指向 $B[1]$，即 $i=0,j=1$。\n\r由于 $B[i]=B[j]$，因此 $next[1]=1$。\n   $x$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$     $next[x]$ $0$ $\\textcolor{red}{1}$           $i$ 和 $j$ 同时向后移一位，看下一位是否也相等。\n\r$B[i]≠B[j]$，出现了不匹配的情况，$next[2]=0$。\n   $x$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$     $next[x]$ $0$ $1$ $\\textcolor{red}{0}$          $i$ 移回 $0$，$j$ 再向后移一位。\n\r$B[i]=B[j]$，$next[3]=1$。\n   $x$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$     $next[x]$ $0$ $1$ $0$ $\\textcolor{red}{1}$         $i$ 和 $j$ 同时向后移一位。\n\r$B[i]=B[j]$，$next[4]=next[3]+1=2$。\n   $x$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$     $next[x]$ $0$ $1$ $0$ $1$ $\\textcolor{red}{2}$        $i$ 和 $j$ 同时向后移一位。\n\r$B[i]=B[j]$，$next[5]=next[4]+1=3$。\n   $x$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$     $next[x]$ $0$ $1$ $0$ $1$ $2$ $\\textcolor{red}{3}$       $i$ 和 $j$ 同时向后移一位。\n$\\cdots \\ \\cdots$\n就这样一直比较到最后一位，再次出现了不匹配的情况。所以 $next[8]$ 应该填 $0$ 吗？显然不是。\n\r查询表格得到 $next[7]=5$，这对应图中的两个绿色子段相等。\n\r查询表格得到 $next[i-1]=next[4]=2$，即图上的这两段相等。\n\r这代表 $B$ 串中的这四段都相等。\n\r于是令 $i=next[i-1]=2$，如果 $B[i]=B[j]$，则 $next[8]=i+1=3$。但是它们并不相等。\n\r于是我们完全可以故技重施，再次令 $i=next[i-1]=1$，结果发现这一次 $B[i]=B[j]$。\n\r因此 $next[8]=i+1=2$。\n   $x$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$     $next[x]$ $0$ $1$ $0$ $1$ $2$ $3$ $4$ $5$ $\\textcolor{red}{2}$    模板 $  int next[]; void getnext(string str) { next[0] = -1; int i = 1, j = 0; while(i \u0026lt; str.size()) { while(j \u0026gt; -1 \u0026amp;\u0026amp; str[i] != str[j]) j = next[j]; next[++ i] = ++ j; } } void kmp(string str, string substr) { getnext(substr); int i = 0, j = 0; while(i \u0026lt; str.size()) { while(j \u0026gt; -1 \u0026amp;\u0026amp; str[i] != substr[j]) j = next[j]; if(j == substr.size() - 1) printf(\u0026#34;Fount pattern at %d\\n\u0026#34;,i - j), j = next[j] - 1; i ++, j ++; } } "}),a.add({id:15,href:'/docs/Math/mod/',title:"同余",section:"数论",content:"定义 $  若 $a,b,m\\in Z,a\\%m=b\\%m$，则 $a$ 和 $b$ 模 $m$ 同余，记作 $a≡b\\pmod{m}$。\n同余类 $    对于任意 $a,k,m\\in Z$，都有 $a+km≡a\\pmod{m}$。集合 ${a+km}$ 为模 $m$ 的 同余类，简记为 $\\overline{a}$。$a$ 是该同余类的 代表元。\n  模 $m$ 的同余类有 $m$ 个，为 $\\overline{0},\\overline{1},\\overline{2},\\cdots,\\overline{m-1}$。\n  同余系 $    从模 $m$ 的所有同余类中各取一个数，构成的集合是 $m$ 的 完全同余系。\n  模 $m$ 的同余类中，代表元与 $m$ 互质的有 $\\phi(m)$ 个。从这些同余类中各取一个数，构成的集合是 $m$ 的 简化同余系。\n  乘法封闭 $  若 $a,b\\in[1,m)$ 分别与 $m$ 互质，则 $ab$ 与 $m$ 互质。\n又 $∵gcd(ab,m)=gcd(m,ab\\%m)=1$，$∴ab\\%m$ 也与 $m$ 互质。\n$∴a,b,ab\\%m$ 都属于 $m$ 的简化同余系。\n因此 $m$ 的简化同余系「关于模 $m$ 乘法封闭」。\n同余定理 $  费马小定理 $  若 $a\\in Z$，$p$ 为质数且 $a,p$ 互质，则 $a^p≡a\\pmod{p}$。\n证明：\n设 $p$ 的完全同余系为 $C={0,1,2,\\cdots,p-1}$，则有 $C_i\\not≡C_j\\pmod{p}$，\n$∵a,C_i,C_j$ 分别与 $p$ 互质，$∴aC_i\\not≡aC_j\\pmod{p}$，\n$∵aC_i\\%p\\in C$，\n$∴aC={0,a,2a,\\cdots,(p-1)·a}$ 也为 $p$ 的完全同余系，\n$∴\\prod_{i=2}^{p}C_i≡\\prod_{i=2}^{p}aC_i=a^{p-1}\\prod_{i=2}^{p}C_i\\pmod{p}$，\n$∴a^{p-1}≡1\\pmod{p}$，即 $a^p≡a\\pmod{p}$。\n欧拉定理 $  若 $a,n\\in Z$ 互质，则 $a^{\\phi(n)}≡1\\pmod{n}$。\n证明：\n设 $n$ 的简化同余系为 $C={C_1,C_2,\\cdots,C_{\\phi(n)}}$，则有 $C_i\\not≡C_j\\pmod{n}$，\n$∵a,C_i,C_j$ 分别与 $n$ 互质，$∴aC_i\\not≡aC_j\\pmod{n}$，\n$∵n$ 的简化同余系「关于模 $n$ 乘法封闭」，$∴aC_i\\%n\\in C$，\n$∴aC={aC_1,aC_2,\\cdots,aC_{\\phi(n)}}$ 也为 $n$ 的简化同余系，\n$∴\\prod_{i=1}^{\\phi(n)}C_i≡\\prod_{i=1}^{\\phi(n)}aC_i=a^{\\phi(n)}\\prod_{i=1}^{\\phi(n)}C_i\\pmod{n}$，\n$∴a^{\\phi(n)}≡1\\pmod{n}$。\n扩展欧拉定理 $  若 $a,n\\in Z$ 互质，则对于任意 $b\\in Z$，有 $a^b≡a^{b \\% \\phi(n)}\\pmod{n}$。\n证明：\n设 $b\\%\\phi(n)=q$，则有 $b=k·\\phi(n)+q(0≤k\u0026lt;\\phi(n))$，\n$∴a^b=a^{k·\\phi(n)+q}=(a^{\\phi(n)})^k·a^q≡a^q=a^{b\\%\\phi(n)}\\pmod{n}$，\n即 $a^b≡a^{b\\%\\phi(n)}\\pmod{n}$。\n扩展欧几里得算法 $  贝祖定理 $  对于任意 $a,b\\in Z$，存在 $x,y\\in Z$，使 $ax+by=gcd(a,b)$。\n乘法逆元 $  若 $a,b,m\\in Z$，$b$ 与 $m$ 互质且 $b|a$，则存在 $x\\in Z$，使 $\\displaystyle\\frac{a}{b}≡ax\\pmod{m}$。称 $x$ 为 $b$ 的模 $m$ 乘法逆元，记为 $b^{-1}\\pmod{m}$。\n"}),a.add({id:16,href:'/docs/DP/basics/',title:"基础 DP",section:"动态规划",content:"斐波那契数列 $  斐波那契数列是形如 $1,1,2,3,5,8,\\cdots$ 的数列。求数列的第 $n$ 项。\n$f[n]$ 表示数列的第 $n$ 项，则：\n$$ f[n]=f[n-1]+f[n-2],n≥3 $$\n   初始条件 $f[1]=f[2]=1$ 计算顺序 $f[3\\rightarrow n]$     边界条件 $f[n]$ 时间复杂度 $O(n)$    int f[]; f[1] = f[2] = 1; for(int i = 3; i \u0026lt;= n; i ++) f[i] = f[i - 1] + f[i - 2]; 汉诺塔问题 $  汉诺塔由 $n$ 个大小不同的圆盘和三根杆子 $a,b,c$ 组成。初始时，$n$个圆盘从大到小依次套在 $a$ 杆上，如下图所示：\n\r现在要求把 $a$ 杆上的 $n$ 个圆盘按以下规则移到 $c$ 杆上：\n  一次只能移动一个圆盘；\n  圆盘只能存放在柱子上；\n  在移动的过程中，大圆盘不能压在小圆盘上。\n  求圆盘的最少移动次数。\n$f[n]$ 表示将 $n$ 个圆盘从一个杆整体移到另一个杆，需要的最少移动次数。\n将 $n$ 个盘子从小到大编号为 $1\\sim n$。将它们从 $a$ 杆移到 $c$ 杆，需要做以下 $3$ 步：\n  将 $a$ 杆上的 $1\\sim n-1$ 号盘移至 $b$ 杆，总移动次数为 $f[n-1]$；\n  将 $a$ 杆上的 $n$ 号盘移至 $c$ 杆，总移动次数为 $1$；\n  将 $b$ 杆上的 $1\\sim n-1$ 号盘移至 $c$ 杆，总移动次数为 $f[n-1]$。\n  $$ f[n]=2·f[n-1]+1,n≥1 $$\n   初始条件 $f[1]=1$ 计算顺序 $f[2\\rightarrow n]$     边界条件 $f[n]$ 时间复杂度 $O(n)$    int f[]; f[1] = 1; for(int i = 2; i \u0026lt;= n; i ++) f[i] = 2 * f[i - 1] + 1; 骨牌问题 $  用若干个 $1×2$ 的骨牌铺满 $2×n$ 的方格。如图为 $n=3$ 时的所有铺法：\n\r求任意的 $n$ 对应的铺法总数。\n$f[n]$ 表示 $2×n$ 方格的铺法总数。对于不好分析的问题，先用枚举法找出规律：\n  若 $n=1$，显然只有一种铺法，$f[1]=1$；\n  若 $n=2$，可以全部竖放，或全部横放，$f[2]=2$\n  若 $n=3$，可以全部竖放，或一个竖放，两个横放，共 $3$ 种放法。$f[3]=3$。\n  \r总结出一般规律：\n  若第一个骨牌竖放在左边，则剩下 $2×(n-1)$ 个方格未铺满，铺法数为 $f[n-1]$；\n  若第一个骨牌横放在左上角，为了不留空，第二个骨牌必须横放在它的正下方。剩下 $2×(n-2)$ 个方格未铺满，铺法数为 $f[n-2]$。\n  $$ f[n]=f[n-1]+f[n-2],n≥3 $$\n状态转移方程恰好和 斐波那契数列相同。\nInfo\n不同问题的状态转移方程可能相同。\n 平面分割 $  平面上有 $n$ 条封闭曲线，每 $2$ 条封闭曲线恰好相交于 $2$ 点，且每 $3$ 条封闭曲线不交于同一点。求 $n$ 条封闭曲线把平面分割成的区域个数。\n\r$a[n]$ 表示 $n$ 条封闭曲线分割成的区域个数，由上图可得：$a[2]-a[1]=2$，$a[3]-a[2]=4$，$a[4]-a[3]=6$，总结出规律: $a[n]-a[n-1]=2(n-1)$。变形得：\n$$ a[n]=a[n-1]+2(n-1),n≥1 $$\n正确性证明：\n新增一条曲线时：\n$∵$ 每与平面上一条已有曲线相交一次，就会增加一个区域，\n$∴$ 新增区域数 $=$ 新增交点数。\n$∵$ 新增的第 $n$ 条曲线与已有的 $n-1$ 条曲线各有 $2$ 个交点，\n$∴$ 新增区域数 $=$ 新增交点数 $=2·(n-1)$。\n$∴$ 现有区域个数 $a[n]=$ 原有区域个数 $+$ 新增区域个数 $=a[n-1]+2(n-1)$。\n   初始条件 $a[1]=2$ 计算顺序 $a[2\\rightarrow n]$     边界条件 $a[n]$ 时间复杂度 $O(n)$    int a[]; a[1] = 2; for(int i = 2; i \u0026lt;= n; i ++) a[i] = a[i - 1] + 2 * (n - 1); 最长上升子序列（LIS） $  Info\n$A$ 的任意子序列 $B$ 可以表示为 $B={A_{k_1} \\ ,A_{k_2} \\ ,\\cdots,A_{k_p} \\ }$ ，其中 $k_1\u0026lt;k_2\u0026lt;\\cdots\u0026lt;k_p$ 。\n若 $A$ 的子序列 $B$ 满足 $A_{k_1}\u0026lt;A_{k_2}\u0026lt;\\cdots\u0026lt;A_{k_p}$ ，则 $B$ 是 $A$ 的上升子序列。\n 数列 $A$ 的长度为 $n$，求 $A$ 的最长上升子序列的长度。\n样例：$A={2,3,6,4,5,1}$，最长上升子序列 $={2,3,4,5}$，长度为 $4$。\n$f[i]$ 表示以 $A_i$ 结尾的最长上升子序列的长度。求 $f[i]$ 时，子问题 $f[1\\sim i-1]$ 已求得最优解，故枚举 $j=1\\cdots i-1$ 并做以下判断：\n  若 $A_j\u0026lt;A_i$，则 $A_i$ 可以接在 $A_j$ 之后，最长上升子序列长度为 $f[j]+1$；\n  若 $A_j≥A_i$，则 $A_i$ 不可以接在 $A_j$ 之后，跳过。\n  $$ f[i]=\\max_{j\u0026lt;i, \\ A_j\u0026lt;A_i}(f[j])+1 $$\n   初始条件 $f[1\\cdots n]=1$ 计算顺序 $f[1\\rightarrow n]$     边界条件 $f[1\\cdots n]$ 的最大值 时间复杂度 $O(n^2)$    for(int i = 1; i \u0026lt;= n; i ++) { f[i] = 1; for(int j = 1; j \u0026lt; i; j ++) if(a[j] \u0026lt; a[i]) f[i] = max(f[i], f[j] + 1); } 单调栈优化 $  运用 单调栈 优化时间复杂度。依次扫描数组元素：\n  若当前元素大于栈顶元素，则将其插入单调栈；\n  否则二分查找栈中第一个比当前元素大的元素，并替换。\n  由于 STL Stack 不支持访问栈内元素，故使用 STL Vector 模拟栈。最终的答案是栈的长度。时间复杂度为 $O(n\\log{n})$。\nvector\u0026lt;int\u0026gt; s = (1, a[1]); for(int i = 2; i \u0026lt;= n; i ++) { if(a[i] \u0026gt; s.back()) s.push_back(a[i]); else s[*lower_bound(s.begin(), s.end(), a[i])] = a[i]; } 最长公共子序列（LCS） $  Info\n若一个序列既是 $A$ 的子序列，又是 $B$ 的子序列，则它是 $A$ 和 $B$ 的公共子序列。\n 给定长度分别为 $n$ 和 $m$ 的两个字符串 $A$、$B$，求 $A$ 和 $B$ 的最长公共子序列[^LCS]长度。\n样例：$A=$ freeze，$B=$ refeze，最长公共子序列 $=$ reeze，长度为 $5$。\n$f[i,j]$ 表示 $A[1\\cdots i]$ 和 $B[1\\cdots j]$ 的最长公共子序列长度。\n  若 $A_i≠B_j$，则继承最优子状态。子问题 $f[i-1,j]$ 和 $f[i,j-1]$ 已求得最优解，故令 $f[i,j]=\\max(f[i-1,j],f[i,j-1])$；\n  若 $A_i=B_j$，则 $A_i$（或 $B_j$）可以接在 $A[1\\cdots i-1]$ 和 $B[1\\cdots j-1]$ 的最长公共子序列之后，生成的新序列长度为 $f[i-1,j-1]+1$。\n  \r$$\rf[i,j]=\\max\\left\\{\\begin{aligned}\r\u0026f[i-1,j]\\\\\r\u0026f[i,j-1]\\\\\r\u0026f[i-1,j-1]+1,A_i=B_j\r\\end{aligned}\\right.\r$$\r\r   初始条件 无 计算顺序 $f[i=1\\rightarrow n,j=1\\rightarrow m]$     边界条件 $f[n,m]$ 时间复杂度 $O(nm)$    for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } 数字金字塔 $  三角矩阵 $A$ 有 $n$ 行，第 $i$ 行有 $i$ 列。从第一行第一列出发，每次可以移动到下一行相邻的两个数字。到达底部时，经过的数字之和最大为多少？\n样例：\n\n最优路径为 $13→8→26→15$，最大值为 $62$。\n$(i,j)$ 表示矩阵第 $i$ 行第 $j$ 列的数字。$f[i,j]$ 表示走到 $(i,j)$ 时，经过的数字之和的最大值。\n采用逆推法：要想走到 $(i,j)$，上一步只能在 $(i-1,j-1)$ 或 $(i-1,j)$：\n  若上一步在 $(i-1,j-1)$，则 $f[i,j]=(i,j)+f[i-1,j-1]$；\n  若上一步 $(i-1,j)$，则 $f[i,j]=(i,j)+f[i-1,j]$。\n  \r$$\rf[i,j]=(i,j)+\\max\\left\\{\\begin{aligned}\r\u0026f[i-1,j-1]\\\\\r\u0026f[i-1,j]\r\\end{aligned}\\right.\r$$\r\r   初始条件 $f[1,1]=(1,1)$ 计算顺序 $f[i=2\\rightarrow n,j=1\\rightarrow i]$     边界条件 $f[n,1\\cdots n]$ 的最大值 时间复杂度 $O(n^2)$    Warning\n当 $j=1$ 或 $j=i$ 时，$f[i-1,j-1]$ 和 $f[i-1,j]$ 会越界。读入数据前要将 $f$ 数组初始化为 $-∞$，从而使越界的元素在取最大值时被自动淘汰。\n memset(f, 0x80, sizeof f); f[1][1] = 1; for(int i = 2; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= i; j ++) { cin \u0026gt;\u0026gt; cnt; f[i][j] = cnt + max(f[i - 1][j - 1], f[i - 1][j]); } for(int i = 1; i \u0026lt;= n; i ++) ans = max(ans, f[n][i]); 数字矩阵 $  数字矩阵 $A$ 有 $n$ 行 $m$ 列。从左上角的元素出发，每次只能向下或向左走。到达右下角时，经过的数字之和最大为多少？\n样例：\n\n最优路径为 $17→1→20→12→9→2$，最大值为 $61$。\n$(i,j)$ 表示矩阵第 $i$ 行第 $j$ 列的数字。$f[i,j]$ 表示走到 $(i,j)$ 时，经过的数字之和的最大值。\n由于只能向左走或向下走，要走到 $(i,j)$，上一步只能在 $(i-1,j)$ 或 $(i,j-1)$：\n\r$$\rf[i,j]=(i,j)+\\max\\left\\{\\begin{aligned}\r\u0026f[i-1,j]\\\\\r\u0026f[i,j-1]\r\\end{aligned}\\right.\r$$\r\r   初始条件 $f[1,1]=(1,1)$ 计算顺序 $f[i=1\\rightarrow n,j=1\\rightarrow m]$     边界条件 $f[n,m]$ 时间复杂度 $O(nm)$    Warning\n当 $i=1$ 或 $j=1$ 时，$f[i-1,j]$ 和 $f[i,j-1]$ 会越界。同样需要将 $f$ 数组初始化为 $-∞$。\n memset(f, 0x80, sizeof f); for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= m; j ++) { cin \u0026gt;\u0026gt; cnt; if(i == 1 \u0026amp;\u0026amp; j == 1) f[i][j] = cnt; else f[i][j] = cnt + max(f[i-1][j], f[i][j - 1]); } 前缀和 $  前缀和是一种重要的预处理技巧，能大幅降低「查询区间元素和」的时间复杂度。\n一维前缀和 $  数列 $A$ 有 $n$ 个元素，$f[i]$ 表示 $A_1+A_2+\\cdots+A_i$，则有：\n$$ f[i]=f[i-1]+A_i $$\n   初始条件 $f[0]=0$ 计算顺序 $f[1]\\rightarrow f[n]$     时间复杂度 $O(n)$      前缀和可以实现快速查询数列的子段和。$g[i,j]$ 表示从 $A_i$ 到 $A_j$ 的所有元素和，则有：\n\r$$ g[i,j]=f[j]-f[i-1] $$\n单次查询的时间复杂度为 $O(1)$。\nint g(int i, int j) { return f[j] - f[i - 1]; } int main() { for(int i = 1; i \u0026lt;= n; i ++) f[i] = f[i - 1] + a[i]; while(cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r) cout \u0026lt;\u0026lt; g(l, r) \u0026lt;\u0026lt; endl; } 二维前缀和 $  矩阵 $A$ 有 $n$ 行 $m$ 列。$f[i,j]$ 表示以 $(1,1)$ 为左上角，以 $(i,j)$ 为右下角的子矩阵的元素和，则：\n\r$$ f[i,j]=f[i-1,j]+f[i,j-1]-f[i-1,j-1]+(i,j) $$\n   初始条件 $f[0,0]=0$ 计算顺序 $f[1\\rightarrow n,1\\rightarrow m]$     时间复杂度 $O(nm)$      二维前缀和可以实现快速查询子矩阵元素和。$g[x_1,y_1,x_2,y_2]$ 表示以 $(x_1,y_1)$ 为左上角，$(x_2,y_2)$ 为右下角的子矩阵元素和，则：\n\r$$ g[x_1,y_1,x_2,y_2]=f[x_2,y_2]-f[x_1-1,y_2]-f[x_2,y_1-1]+f[x_1-1,y_1-1] $$\n单次查询的时间复杂度为 $O(1)$。\nint g(int x1, int y1, int x2, int y2) { return f[x2][y2] - f[x1 - 1][y2] - f[x2][y1 - 1] + f[x1 - 1][y1 - 1]; } int main() { f[0][0] = 0; for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= m; j ++) f[i][j] = f[i - 1][j] + f[i][j - 1] + a[i][j]; while(cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2) cout \u0026lt;\u0026lt; g(x1, y1, x2, y2) \u0026lt;\u0026lt; endl; } 差分 $  差分是 前缀和 的逆运算，能大幅降低「区间批量操作」的时间复杂度。\n数列 $A$ 有 $n$ 个元素。$f[i]$ 代表数列 $A$ 第 $i$ 项和前一项的差，即：\n$$ f[i]=A_i-A_{i-1} $$\n   初始条件 $f[1]=A_1$ 计算顺序 $f[1\\rightarrow n]$     时间复杂度 $O(n)$      $f$ 被称作「差分数列」。数列 $A={5,2,3,1,6,4}$ 的差分数列为 $f={5,-3,1,-2,5,-2}$。\n将 $A[l\\cdots r]$ 中的每个元素都加上 $x$ 时，差分数列中 $f[l]$ 增加了 $x$，$f[r+1]$ 减少了 $x$，其余元素不变。因此每次只修改 $f[l]$ 和 $f[r+1]$ 的值，最后通过 $f$ 数列还原 $A$ 中的元素，即：\n$$ A_i=A_{i-1}+f[i] $$\n单次批量操作的时间复杂度为 $O(1)$。\nvoid add(int l, int r, int x) {// 将区间 [l, r] 批量加 x  f[l] += x, f[r + 1] -= x; } void query() { // 还原数组元素  for(int i = 1; i \u0026lt;= n; i ++) a[i] = a[i - 1] + f[i]; } int main() { for(int i = 1; i \u0026lt;= n; i ++) f[i] = a[i] - a[i - 1]; int l, r, x; while(cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x) { add(l, r, x); } query(); } "}),a.add({id:17,href:'/docs/Basics/sort/',title:"排序算法",section:"基础算法",content:"选择排序 $  每次找出第 $i$ 小的元素，与数组第 $i$ 个位置上的元素交换。时间复杂度为 $O(n^2)$。\nfor(int i = 1; i \u0026lt;= n; i ++) for(int j = i + 1; j \u0026lt;= n; j ++) if(a[j] \u0026lt; a[k]) swap(a[i],a[k]); 冒泡排序 $  每次检查相邻两个元素，如果前一个大于后一个，就交换它们的位置。当没有可交换的元素时，排序结束。时间复杂度为 $O(n^2)$。\n在程序的执行过程中，较大的元素像气泡般「浮」到数列的末尾，故叫做冒泡排序。\nwhile(true) { bool solve = false; for(int i = 1; i \u0026lt;= n; i ++) if(a[i] \u0026gt; a[i + 1]) swap(a[i], a[i + 1]), solve = true; if(!solve) break; } 插入排序 $  将数列分为「已排序」和「未排序」两部分，每次从「未排序」区域中选择一个元素插入「已排序」区域的正确位置。时间复杂度为 $O(n^2)$。\nfor(int i = 2; i \u0026lt;= n; i ++) { int cnt = a[i], j = i - 1; while(j \u0026gt;= 1 \u0026amp;\u0026amp; a[j] \u0026gt; cnt) a[j + 1] = a[j --]; a[j + 1] = cnt; } 计数排序 $  $f[i]$ 表示元素 $i$ 的出现次数。\n  扫描数组，将当前元素 $v$ 对应的 $f[v]$ 加一；\n  遍历 $f[i=1\\cdots maxn]$，依次输出 $f[i]$ 个 $i$。\n  时间复杂度为 $O(n)$。\nWarning\n当元素范围过大时，不宜使用计数排序。\n int maxn = -1e9, p = 1; for(int i = 1; i \u0026lt;= n; i ++) { f[a[i]] ++; maxn = max(maxn, a[i]); } for(int i = 1; i \u0026lt;= maxn; i ++) for(int i = 1; i \u0026lt;= f[i]; i ++) a[++ p] = i; 快速排序 $    设定基准数（通常是数列最中间的数），将小于基准数的数放在它左边，大于它的放在右边；\n  递归排序基准数的左右两部分。\n  平均时间复杂度为 $o(n\\log{n})$，最坏时间复杂度为 $O(n^2)$。\nvoid qsort(int l, int r) { if(l \u0026gt;= r) return; int i = l, j = r, m = (l + r) / 2; while(i \u0026lt;= j) { while(a[i] \u0026lt; a[m]) i ++; while(a[j] \u0026gt; a[m]) j --; if(i \u0026lt;= j) swap(a[i ++], a[j --]); } qsort(l, j), qsort(i, r); } 归并排序 $    将数列分为左右两个子序列；\n  递归排序左右子序列；\n  合并两个子序列。\n  时间复杂度为 $O(n\\log{n})$。\nvoid msort(int l, int r) { if(l == r) return; int m = (l + r) / 2; msort(l, m), msort(m + 1, r); int i = l, j = m + 1, k = l; while(i \u0026lt;= m \u0026amp;\u0026amp; j \u0026lt;= r) if(a[i] \u0026lt;= a[j]) b[k ++] = a[i ++]; else b[k ++] = a[j ++]; while(i \u0026lt;= m) b[k ++] = a[i ++]; while(j \u0026lt;= n) b[k ++] = a[j ++]; for(int i = l; i \u0026lt;= r; i ++) a[i] = b[i]; } 猴子排序 $  从数列中随机选取两个元素交换位置，重复直到所有元素升序排列。平均时间复杂度为 $O(n·n!)$，最优时间复杂度为 $O(n)$，最坏时间复杂度为 $O(∞)$。\nsrand(unsigned(time(0))); // 伪随机种子 while(true) { swap(a[rand() % n + 1], a[rand() % n + 1]); bool solve = true; for(int i = 2; i \u0026lt;= n; i ++) if(a[i] \u0026lt; a[i - 1]) solve = false; if(solve) break; } 各类排序算法的比较 $     排序算法 平均 最好 最坏 稳定性     选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ 不稳定   冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ 稳定   插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ 稳定   计数排序 $O(n)$ $O(n)$ $O(n)$ 稳定   快速排序 $O(n\\log{n})$ $O(n\\log{n})$ $O(n^2)$ 不稳定   归并排序 $O(n\\log{n})$ $O(n\\log{n})$ $O(n\\log{n})$ 稳定   猴子排序 $O(n·n!)$ $O(n)$ $O(∞)$ 不稳定    求逆序对 $  Warning\n该模块正在开发中。\n "}),a.add({id:18,href:'/docs/Graph/path/',title:"最短路",section:"图论",content:"松弛操作（relax） $  用 邻接矩阵 $g[ \\ ][ \\ ]$ 存储边。如果 $g[i][k] + g[k][j] \u0026lt; g[i][j]$，则说明「先从 $i$ 走到 $k$，再走到 $j$」比原先的路径更快，此时令 $g[i][j] = g[i][k] + g[k][j]$。\nFloyed 算法 $  $g[k][i][j]$ 表示只允许经过节点 $1 \\sim k$ 时，从节点 $i$ 到 $j$ 的最短路径。\n当节点 $k$ 被允许经过时，枚举路径的两个端点 $i$ 和 $j$：\n  若不经过节点 k，则 $g[k][i][j] = g[k - 1][i][j]$；\n  若经过节点 k，则 $g[k][i][j] = g[k - 1][i][k] + g[k - 1][k][j]$。\n  $g[k][i][j] = max(g[k - 1][i][j], g[k - 1][i][k] + g[k - 1][k][j])$。\nfor(int k = 1; k \u0026lt;= n; k ++) for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= n; j ++) g[k][i][j] = min(g[k - 1][i][j], g[k - 1][i][k] + g[k - 1][k][j]); 实际上，Floyed 算法的第一维不影响结果，可以省去。\nfor(int k = 1; k \u0026lt;= n; k ++) for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= n; j ++) g[i][j] = min(g[i][j], g[i][k] + g[k][j]); Floyed 算法适用于任何图，但必须存在最短路。时间复杂度为 $O(n^3)$。\nBellman-Ford 算法 $  Bellman-Ford 算法是 Floyed 算法的优化版本。枚举节点的效率太低，改为枚举边。\nn 个节点 m 条边的图中，如果存在最短路径，则最短路径所包含的边数 $≤ n-1$。故每条路最多被松弛 $n-1$ 次。$dis[i]$ 表示从节点 s 到节点 i 的最短路长度，初始时要设为无穷大。\nBellman-Ford 算法只能处理单源最短路径，不能处理负权回路。时间复杂度为 $O(nm)$。\nvoid bellman_ford(int s) { memset(dis, 0x7f, sizeof dis); for(int i = 1; i \u0026lt; n; i ++) // 松弛 n-1 次  for(int j = 1; j \u0026lt;= m; j ++) dis[to[j]] = min(dis[to[j]], dis[from[j]] + len[j]); } 判断负权回路 $  若图中存在长度为负数的 回路，则此回路称为负权回路（负环）。有负权回路的图不存在最短路。\n使用 Bellman-Ford 算法时，如果一条路能被松弛 $n$ 次即以上，则一定存在负权回路。\nbool check(int s) { memset(dis, 0x7f, sizeof dis); for(int i = 1; i \u0026lt; n; i ++) for(int j = 1; j \u0026lt;= m; j ++) dis[to[j]] = min(dis[to[j]], dis[from[j]] + len[j]); for(int j = 1; j \u0026lt;= m; j ++) if(dis[to[j]] \u0026gt; dis[from[j]] + len[j]) return false; // 松弛了 n - 1 次后，还能进行松弛操作，则存在负权回路  return true; } SPFA 算法 $  SPFA 算法是 Bellman-Ford 算法的队列优化版本。只有上一次被松弛的结点的出边，才有可能引起下一次的松弛操作。每次取队首节点，对其出边进行松弛，将松弛到的节点加入队列。时间复杂度为 $O(kn)$，$k$ 为常数。\nvoid spfa(int s) { memset(avl, true, sizeof avl); memset(dis, 0x7f, sizeof dis); queue\u0026lt;int\u0026gt; Q; Q.push(s); dis[s] = 0, avl[s] = false; while(!Q.empty()) { int cur = Q.front(); Q.pop(); for(int i = 0; i \u0026lt; (int) g[cur].size(); i ++) { int v = g[cur][i].val; int d = g[cur][i].len; if(dis[v] \u0026gt; dis[cur] + d) { dis[v] = dis[cur] + d; if(!avl[v]) continue; avl[v] = false; Q.push(v); } } } } 卡 SPFA $  SPFA 遇到以下几类图时，时间复杂度会退化成 $O(n^2)$。设计特定的数据卡 SPFA 算法也成了出题者最热衷于做的事情之一。\n1. 网格图 $  \r2. 链套菊花 $  \rDijkstra 算法 $  从节点 $s$ 出发。首先把所有节点分成两个集合：已确定最短路长度的，和未确定的。一开始只有 $s$ 在第一个集合，且 $dis[s] = 0,dis[$ 除 $s$ 以外的其他节点 $]=∞$。\n重复以下操作直到第二个集合中没有节点：\n  松弛刚加入第一个集合的节点的所有出边。\n  从第二个集合中，选取 $dis$ 值最小的节点，加入第一个集合。\n  只能处理单源最短路径，不能处理负权路径。时间复杂度为 $O(n^2)$。\nvoid dijkstra(int s) { memset(avl, true, sizeof avl); memset(dis, 0x7f, sizeof dis); dis[s] = 0; for(int i = 1; i \u0026lt;= n; i ++) { int minn = INF, minp = 0; for(int j = 1; j \u0026lt;= n; j ++) if(avl[j] \u0026amp;\u0026amp; dis[j] \u0026lt; minn) minn = dis[j], minp = j; if(!minp) continue; avl[minp] = false; for(int j = 1; j \u0026lt;= n; j ++) if(avl[j] \u0026amp;\u0026amp; dis[j] \u0026gt; minn + g[minp][j]) dis[j] = minn + g[minp][j]; } } "}),a.add({id:19,href:'/docs/Graph/Tree/LCA/',title:"最近公共祖先",section:"树",content:"简介 $  节点 $p$ 和 $q$ 的最近公共祖先（节点 $s$）是 $p$ 到 $q$ 最短路径中深度最浅的节点：\n\r基本原理 $    从 $p$ 节点开始，不断往父节点移动，直到遇到根节点。标记运动路径中经过的节点；\n  从 $q$ 节点开始，不断往父节点移动，直到遇到的节点被标记过。该节点是 $p$ 和 $q$ 的最近公共祖先。\n  \r时间复杂度：$O(n)$。\nint fa[]; bool mark[]; /* fa[i] : 节点 i 的父节点，fa[根节点] = 0 mark[i] : 节点 i 是否被标记 */ int LCA(int p, int q) { // 返回节点 p 和 q 的最近公共祖先  memset(mark, false, sizeof mark); while(p) mark[p] = true, p = fa[p]; while(!mark[q]) q = fa[q]; return q; } "}),a.add({id:20,href:'/docs/DS/link/',title:"链表",section:"数据结构",content:'简介 $    链表只能按顺序依次访问元素，而数组支持随机访问。\n  链表支持在任意位置插入或删除元素，而数组不支持。\n  链表节点 $  用一个结构体表示链表的节点，其中可以存储任意数据。另外用 prev 和 next 两个指针指向前后相邻的节点。\nstruct Node { int val; // 数据（可以是任意类型）  Node *prev, *next; // 指针 }; 初始化 $  初始化链表时，额外建立两个节点 head 和 tail 代表链表头尾，把实际节点存储在 head 与 tail 之间，简化链表边界的判断。\nNode *head, *tail; void init() { head = new Node(); tail = new Node(); head-\u0026gt;next = tail; tail-\u0026gt;prev = next; } 插入/删除节点 $  如何在 $1$ 和 $2$ 之间插入 $3$ ？\n mermaid.initialize({ "flowchart": { "useMaxWidth":true }, "theme": "default" } ) flowchart LR\r3((3))\r1((1))2((2))\r 让 $3$ 的 next 指向 $2$，$2$ 的 prev 指向 $3$：  flowchart LR\r1((1))2((2))\r3((3))2((2))\r让 $1$ 的 next 指向 $3$，$3$ 的 prev 指向 $1$：  flowchart TD\r1((1)) \u0026 2((2))3((3))\r删除节点运用到类似的方法。\nvoid insert(Node *pri, int val) { // 在节点 pri 后面插入数据为 val 的新节点  q = new Node(); q-\u0026gt;val = val; Node *aft = pre-\u0026gt;next; aft-\u0026gt;prev = q, q-\u0026gt;next = aft; // 步骤 1  pri-\u0026gt;next = q, q-\u0026gt;prev = pri; // 步骤 2 } void remote(Node *p) { // 删除节点 p  p-\u0026gt;prev-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next-\u0026gt;prev = p-\u0026gt;prev; delete p; } 查找节点 $  Node* indexOf(int val) { // 返回链表中第一个出现的值为 val 的节点指针  for(Node *p = head-\u0026gt;next; p != tail; p = p-\u0026gt;next) if(p-\u0026gt;val == val) return p; return NULL; } 清空链表 $  void clear() { while(head != tail) { head = head-\u0026gt;next; delete head-\u0026gt;prev; } delete tail; } 用数组模拟链表 $  使用指针动态分配空间，效率较低且不稳定。一般使用数组模拟链表。\nstruct Node { int val; int prev, next; } node[]; int head, tail, tot; void init() { head = 0, tail = 1, tot = 2; node[head].next = tail; node[tail].prev = head; } void insert(int p, int val) { int q = ++ tot; node[q].val = val; node[node[p].next].prev = q; node[q].next = node[p].next; node[p].next = q, node[q].next = p; } void remove(int p) { node[node[p].prev].next = node[p].next; node[node[p].next].prev = node[p].prev; } int indexOf(int val) { for(int p = node[head].next; p != tail; p = node[p].next) if(node[p].val == val) return p; return -1; } void clear() { head = tail = tot = 0; memset(node, 0, sizeof node); } '}),a.add({id:21,href:'/docs/DS/queue/',title:"队列",section:"数据结构",content:"简介 $  队列是一种「先进先出」的数据结构。元素从队列的前端进入（入队），从末端离开（出队），类似于排队。基本操作见 STL Queue。\n\r双向队列 $  队列元素只能从一端进，另一端出，有时无法满足问题的需要。双向队列应运而生，它支持从两端插入或删除元素。\n双向队列的基本操作见 STL Deque。\n单调队列 $  单调队列的元素从队头到队尾满足单调性，适用于查询某一动态区间的最大（或最小）元素。\n插入元素 $  将 $A[i]$ 入队，维护队列单调性，同时保证队列元素在 $A[p\\cdots i]$ 范围内。以单调递增队列为例：\n  重复弹出队头，直到队头 $≥p$；\n  重复弹出队尾，直到 $A[$队尾$]\u0026lt;A[i]$（若单调递减，则重复直到 $A[$队尾$]\u0026gt;A[i]$）。\n  将 $i$ 入队。\n  涉及双端操作，须使用双向队列。此时 $A[p\\cdots i]$ 范围内最小元素为 $A[$队头$]$。\ndeque\u0026lt;int\u0026gt; q; // 存储元素下标  void insert(int i, int p) { // 将 a[i] 入队，维护队列元素在 a[p...i] 范围内  while(!q.empty() \u0026amp;\u0026amp; q.front() \u0026lt; p) q.pop_front(); while(!q.empty() \u0026amp;\u0026amp; a[q.back()] \u0026gt;= a[i]) q.pop_back(); q.push_back(i); } 滑动窗口 $  一个滑动窗口（长度为 $k$）从数组 $A$ （长度为 $n$）的左端移动到右端，每次只向右移一位。求每次滑动时窗口区中的最大值。\n示例（$k=3,n=8$，红色数值在窗口区内）：\n   $A_1$ $A_2$ $A_3$ $A_4$ $A_5$ $A_6$ $A_7$ $A_8$ 最大值     1 3 -1 -3 5 3 6 7 3   1 3 -1 -3 5 3 6 7 3   1 3 -1 -3 5 3 6 7 5   1 3 -1 -3 5 3 6 7 5   1 3 -1 -3 5 3 6 7 6   1 3 -1 -3 5 3 6 7 7    朴素算法 $  枚举 $i=k\\rightarrow n$，枚举出区间 $[i-k+1,i]$ 中的最大整数。时间复杂度为 $O(nk)$。\nfor(int i = k; i \u0026lt;= n; i ++) { int maxn = a[i]; for(int j = i - k + 1; j \u0026lt;= i; j ++) maxn = max(maxn, a[j]); cout \u0026lt;\u0026lt; maxn \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } 单调队列优化 $  使用单调递减队列优化「查找区间 $[i-k+1,i]$ 中的最大整数」的效率。时间复杂度为 $O(n)$。\ndeque\u0026lt;int\u0026gt; q; void insert(int i, int p) { while(!q.empty() \u0026amp;\u0026amp; q.front() \u0026lt; p) q.pop_front(); while(!q.empty() \u0026amp;\u0026amp; a[q.back()] \u0026lt;= a[i]) q.pop_back(); q.push_back(i); } for(int i = 1; i \u0026lt;= n; i ++) { insert(i, i - k + 1); if(i \u0026gt;= k) cout \u0026lt;\u0026lt; a[q.front()] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } "}),a.add({id:22,href:'/docs/String/trie/',title:"Trie 树",section:"字符串",content:"int trie[][], tot; bool end[]; void insert(string str) { // 往 trie 树中插入字符串 str  int p = 0; for(int i = 0; i \u0026lt; str.size(); i ++) { int ch = str.at(i); if(!trie[p][ch]) trie[p][ch] = ++ tot; p = trie[p][ch]; } end[p] = true; } bool search(string str) { // 查询 trie 树中是否有字符串 str  int p = 0; for(int i = 0; i \u0026lt; str.size(); i ++) { int ch = str.at(i); if(!trie[p][ch]) return false; p = trie[p][ch]; } return end[p]; } "}),a.add({id:23,href:'/docs/Basics/binary/',title:"二分算法",section:"基础算法",content:"简介 $  玩过「数字炸弹」游戏吗？\n  叫你的朋友在你背后写一个 $[1,1000]$ 中的正整数 $n$；\n  每轮你都会给出数字 $x$，你朋友只能回答「$n$ 比 $x$ 大」「$n$ 比 $x$ 小」或「猜中」。\n  一旦猜中，数字炸弹就会爆炸。你能求出引爆炸弹的最少次数吗？\n最初 $n∈(0,1001)$。你可以先猜 $500$：\n  若 $n\u0026gt;500$，则可以进一步确定 $n∈(500,1001)$；\n  若 $n\u0026lt;500$，则可以进一步确定 $n∈(0,500)$；\n  否则 $n=500$，猜中。\n  重复猜范围的中间数，每次都会将 $n$ 的范围缩小一半，最多 $\\log{n}$ 次就可以确定 $n$ 的值。\n通过若干次折半范围实现快速查询，是二分算法的基本思想。\n基本原理 $  $l$ 表示 $n$ 所在范围的左端点，$r$ 表示右端点，即 $n∈(l,r)$。重复执行以下操作：\n  取范围的中间数 $m=\\lfloor(l+r)/2\\rfloor$；\n  若 $n\u0026gt;m$，则可以确定 $n∈(m,r)$，令 $l=m$；\n  若 $n\u0026lt;m$，则可以确定 $n∈(l,m)$，令 $r=m$；\n  若 $n=m$，跳出循环。\n  初始条件：$l=0,r=1001$。时间复杂度为 $O(\\log{n})$。\nint binSearch(int n) { // 使用二分算法猜出 n 的最少次数  int l = 0, r = 1001, frq = 0; // frq 记录次数  while(++ frq) { int m = (l + r) / 2; if(n \u0026gt; m) l = m; else if(n \u0026lt; m) r = m; else break; } return frq; } "}),a.add({id:24,href:'/docs/DS/heap/',title:"二叉堆",section:"数据结构",content:"简介 $  二叉堆（Binary Heap） 是一种基于完全二叉树的数据结构。\n  小根堆：任意节点 $≥$ 其父节点，根节点最小。\n  大根堆：任意节点 $≤$ 其父节点，根节点最大。\n  \r本篇以小根堆为例，介绍二叉堆的实现方式。\n构造 $  按照「从上到下，从左到右」的顺序给节点编号。\n\r该二叉堆具有以下性质：\n  $1$ 号节点是根节点。\n  $u$ 号节点的父节点为 $u÷2$（向下取整）。\n  $u$ 号节点的左子节点为 $2u$，右子节点为 $2u+1$。\n  二叉堆的任意一条支路都按照升序排序。\n  \r使用数组保存二叉堆。\nint t[], n; // t[u] : u 号节点的值 // n : 节点总数 插入 $  如何往小根堆中插入元素 $2$？\n  在堆底新建节点，值为 $2$；\n  对新节点所在支路进行排序。重复执行以下步骤：\n 若新节点 $\u0026lt;$ 其父节点，则交换它们的位置，否则跳出循环。    \r时间复杂度为 $O(n\\log{n})$。\nvoid push(int val) { // 插入元素 val  t[++ n] = val; // 新建节点  for(int u = n; u != 1; u /= 2) { if(t[u] \u0026lt; t[u / 2]) swap(t[u], t[u / 2]); else break; } } 移除 $  将小根堆的根节点移除，如何调整使其仍为小根堆？\n\r  把堆底最后一个元素移到根节点；\n  从根节点 $u=1$ 开始，重复执行以下步骤：\n  比较 $u$ 的两个子节点，取最小的一个，记为 $v$；\n  若 $t[u]\u0026gt;t[v]$，交换节点 $u$ 和 $v$ 的位置，并使 $u=v$，否则跳出循环。\n    \rvoid pop() { // 移除根节点  t[1] = t[n --]; for(int u = 1; 2 * u \u0026lt;= n; ) { int v = 2 * u; if(v + 1 \u0026lt;= n \u0026amp;\u0026amp; t[v + 1] \u0026lt; t[v]) v ++; // 取最小的子节点  if(t[u] \u0026gt; t[v]) swap(t[u], t[v]), u = v; else break; } } 模板 $  int t[], n; void push(int val) { t[++ n] = val; for(int u = n; u != 1; u /= 2) { if(t[u] \u0026lt; t[u / 2]) swap(t[u], t[u / 2]); else break; } } void pop() { t[1] = t[n --]; for(int u = 1; 2 * u \u0026lt;= n; ) { int v = 2 * u; if(v + 1 \u0026lt;= n \u0026amp;\u0026amp; t[v + 1] \u0026lt; t[v]) v ++; if(t[u] \u0026gt; t[v]) swap(t[u], t[v]), u = v; else break; } } "}),a.add({id:25,href:'/docs/Math/quickpow/',title:"快速幂",section:"数论",content:"typedef long long LL; LL Pow(LL a, LL b) { // 计算 a^b  if(!b) return 1; LL res = Pow(a, b / 2); return res * res + (b % 2) * a; } "}),a.add({id:26,href:'/docs/Graph/topsort/',title:"拓扑排序",section:"图论",content:"AOV 网 $  给出几组关系：$a \u0026gt; b$，$a \u0026gt; c$，$b \u0026gt; c$，$b \u0026gt; d$，$\\cdots$，求可能的 $a \\ b \\ c \\ d \\cdots$ 的大小顺序？\n将上述关系转化为有向图，其中 $a → b$ 代表 $a \u0026gt; b$。这类能表示节点大小关系的图称做 AOV 网。\n\r基本原理 $  拓扑排序 求的是合法的优先顺序，求得的序列称为 拓扑序列。同一张 AOV 网可能有多个合法的拓扑序列。\nInfo\n没被箭头指着的节点（入度为 $0$ 的节点）是当前最大的节点。\n Step 1 节点 $a$ 的入度为 $0$。在拓扑序列中追加 $a$，并删除 $a$ 和它的所有邻边：\n\r拓扑序列：$a$。\nStep 2 节点 $e$ 的入度为 $0$。在拓扑序列中追加 $e$，并删除 $e$ 和它的所有邻边：\n\r拓扑序列：$a \\ e$。\nStep 3 节点 $b$ 的入度为 $0$。在拓扑序列中追加 $b$，并删除 $b$ 和它的所有邻边：\n\r拓扑序列：$a \\ e \\ b$。\n$\\cdots \\ \\cdots$  故样例的一种拓扑序列为 $a \\ e \\ b \\ c \\ d \\ f$。\n$deg[i]$ 表示节点 $i$ 的入度，在输入时可以预处理。\n  定义一个队列，用于存放结点；\n  将所有入度为 $0$ 的节点入队；\n  将队头结点出队，并删除该结点的所有出边。若出现新的结点入度为零，则将其入队。\n  拓扑排序结束时，若拓扑序列未包含全部节点，则说明剩下的节点形成了闭环。此时不存在合法拓扑序列。\nvector\u0026lt;int\u0026gt; topSort() { vector\u0026lt;int\u0026gt; vec; queue\u0026lt;int\u0026gt; q; for(int i = 1; i \u0026lt;= n; i ++) if(!deg[i]) q.push(i); while(!q.empty()) { int top = q.front(); q.pop(); vec.push_back(top); for(int i = 0; i \u0026lt; g[top].size(); i ++) if(! -- deg[g[top][i]]) q.push(g[top][i]); } if(vec.size() != n) return vector\u0026lt;int\u0026gt;(); return vec; } "}),a.add({id:27,href:'/docs/Graph/Tree/MST/',title:"最小生成树",section:"树",content:"简介 $   无向图 $G$ 的生成树同时满足以下性质：\n  包含 $G$ 中的所有节点；\n  任意两个节点都 连通；\n  具有树的所有性质。\n  下图的 $b$ 和 $c$ 皆为 $a$ 的生成树。\n\r最小生成树是所有生成树中边权和最小的树。$n$ 个节点的无向图中，最小生成树有 $n-1$ 条边。\nKruskal 算法 $  Kruskal 算法是一种贪心算法。\n  将 $m$ 条边按照边权升序排序；\n  从小到大枚举边，若此边的两个顶点未连通，则在树中加入此边，并连通两个顶点。重复直到共加入 $n-1$ 条边。\n  使用 并查集判断和维护两个顶点是否连通。\n时间复杂度为 $O(m\\log{m})$，适用于稀疏图。\nint n, m, fa[]; struct edge { int x, y, len; } g[]; bool cmp(edge x, edge y) { return x.len \u0026lt; y.len; } int find(int x) { return !fa[x] ? x : fa[x] = find(fa[x]); } int kruskal() { sort(g + 1, g + m + 1, cmp); int tot = 0, sum = 0; for(int i = 1; i \u0026lt;= m; i ++) { if(tot == n - 1) break; int rx = find(g[i].x); int ry = find(g[i].y); if(rx != ry) { tot ++, fa[rx] = ry, sum += g[i].len; } } return tot == n - 1 ? sum : -1; //如果存在最小生成树，则返回边权和，否则返回 -1 } Prim 算法 $  $dis[i]$ 表示节点 $i$ 到树的最短距离。\n  建立一棵只有节点 $1$ 的树，$dis[1]=0$；\n  选择离树最近（$dis$ 值最小）的点加入树，对该点的相邻节点进行 松弛操作。重复执行直到加入 $n-1$ 条边。\n  时间复杂度为 $O(n^2)$，适用于稠密图。\nint prim() { int sum = 0; memset(avl, true, sizeof avl); memset(dis, 0x7f, sizeof dis); dis[1] = 0; for(int i = 2; i \u0026lt;= n; i ++) { int minn = INF, minp = 0; for(int j = 2; j \u0026lt;= n; j ++) if(avl[j] \u0026amp;\u0026amp; dis[j] \u0026lt; minn) minn = dis[j], minp = j; if(!minp) return -1; avl[minp] = false, sum += minn; for(int j = 1; j \u0026lt;= n; j ++) if(avl[j] \u0026amp;\u0026amp; dis[j] \u0026gt; g[minp][j]) dis[j] = g[minp][j]; } return sum; } "}),a.add({id:28,href:'/docs/DP/knap/',title:"背包 DP",section:"动态规划",content:"01 背包 $  用体积为 $m$ 的背包装 $n$ 种物品，每种物品只有 $1$ 个。第 $i$ 种物品的体积为 $w_i$，价值为 $c_i$，将哪些物品装入背包可使总价值最大？\n$f[i,v]$ 表示把前 $i$ 个物品（部分或全部）放入体积为 $v$ 的背包，可以获得的最大总价值。\n若只考虑第 $i$ 个物品的策略（放或不放），则问题转而只涉及到前 $i-1$ 个物品：\n  若不放第 $i$ 个物品，则 $f[i,v]=f[i-1,v]$；\n  若放第 $i$ 个物品，则前 $i-1$ 个物品只能放在体积为 $v-w_i$ 的空间里，故 $f[i,v]=f[i-1,v-w_i]+c_i$。\n  \r$$\rf[i,v] = \\max\\left\\{\\begin{aligned}\r\u0026f[i-1,v]\\\\\r\u0026f[i-1,v-w_i]+c_i,v≥w_i\r\\end{aligned}\\right.\r$$\r\r由于 $f[i,v]$ 的值只由 $f[i-1,v]$ 和 $f[i-1,v-w_i]$ 决定，所以先求 $f[1,0\\cdots m]$，再求 $f[2,0\\cdots m]$，$\\cdots$，直到求出 $f[n,m]$。时间复杂度为 $O(nm)$。\nWarning\n当 $v \u0026lt; w_i$ 时，第 $i$ 个物品放不进体积为 $v$ 的背包，此时 $f[i,v]$ 只能等于 $f[i-1,v]$。\n for(int i = 1; i \u0026lt;= n; i ++) { for(int v = 0; v \u0026lt; w[i]; v ++) f[i][v] = f[i - 1][v]; for(int v = w[i]; v \u0026lt;= m; v ++) f[i][v] = max(f[i - 1][v], f[i - 1][v - w[i]] + c[i]); } 空间优化 $  假设背包体积为 $4$，物品个数为 $3$，体积和价值如下：\n   序号 体积 $w$ 价值 $c$     $1$ $1$ $2$   $2$ $2$ $3$   $3$ $1$ $3$    第 $i$ 行第 $v$ 列的格子 $(i,v)$ 存放 $f[i,v]$ 的值。运行 01 背包程序可以得到下表：\n   $i\\setminus v$ $0$ $1$ $2$ $3$ $4$     $0$ $0$ $0$ $0$ $0$ $0$   $1$ $0$ $2$ $2$ $2$ $2$   $2$ $0$ $2$ $3$ $5$ $5$   $3$ $0$ $3$ $5$ $6$ $8$    由于每一行的数据只与上一行有关，事实上可以去掉 $1$ 维：\n\r$$\rf[\\color{lightgray}i,\\color{black}v] = \\max\\left\\{\\begin{aligned}\r\u0026f[\\color{lightgray}i-1,\\color{black}v]\\\\\r\u0026f[\\color{lightgray}i-1,\\color{black}v-w_i]+c_i,v≥w_i\r\\end{aligned}\\right.\r$$\r\r需要保证更新 $f[v]$ 时，$f[v-w_i]$ 在第 $i$ 行还没被更新，因此降序枚举 $v$。\n用 $1$ 号物品（$w_1=1,c_1=2$）更新 $f[4\\cdots 0]$：\n   $f\\setminus v$ $0$ $1$ $2$ $3$ $4$     $f$（上一行） $0$ $0$ $0$ $0$ $0$   更新 $f[4]$ $0$ $0$ $0$ $\\color{blue}{0}$ $\\color{blue}{f[4-1]}\\color{red}{+2}$   更新 $f[3]$ $0$ $0$ $\\color{blue}{0}$ $\\color{blue}{f[3-1]}\\color{red}{+2}$ $2$   更新 $f[2]$ $0$ $\\color{blue}{0}$ $\\color{blue}{f[2-1]}\\color{red}{+2}$ $2$ $2$   更新 $f[1]$ $\\color{blue}{0}$ $\\color{blue}{f[1-1]}\\color{red}{+2}$ $2$ $2$ $2$   更新 $f[0]$ $\\color{blue}{f[0]=0}$ $2$ $2$ $2$ $2$   $f$ $0$ $2$ $2$ $2$ $2$    for(int i = 1; i \u0026lt;= n; i ++) for(int v = m; v \u0026gt;= w[i]; v --) f[v] = max(f[v], f[v - w[i]] + c[i]); 完全背包 $  如果每种物品都有无限个？\n$f[i,v]$ 表示把前 $i$ 种物品放入体积为 $v$ 的背包，可以获得的最大总价值。\n  若不放第 $i$ 种物品，则 $f[i,v]=f[i-1,v]$；\n  若多放入 $1$ 个第 $i$ 种物品，则剩余的前 $i$ 种物品只能放在体积为 $v-w_i$ 的空间里，故 $f[i,v]=f[i,v-w_i]+c_i$。\n  \r$$\rf[i,v] = \\max\\left\\{\\begin{aligned}\r\u0026f[i-1,v]\\\\\r\u0026f[i,v-w_i]+c_i,v≥w_i\r\\end{aligned}\\right.\r$$\r\r时间复杂度为 $O(nm)$。\nfor(int i = 1; i \u0026lt;= n; i ++) { for(int v = 0; v \u0026lt; w[i]; v ++) f[i][v] = f[i - 1][v]; for(int v = w[i]; v \u0026lt;= m; v ++) f[i][v] = max(f[i - 1][v], f[i][v - w[i]] + c[i]); } 空间优化 $  完全背包同样也可以省去一维：\n\r$$\rf[\\color{lightgray}i,\\color{black}v] = \\max\\left\\{\\begin{aligned}\r\u0026f[\\color{lightgray}i-1,\\color{black}v]\\\\\r\u0026f[\\color{lightgray}i,\\color{black}v-w_i]+c_i,v≥w_i\r\\end{aligned}\\right.\r$$\r\r需要保证更新 $f[v]$ 时，$f[v-w_i]$ 在第 $i$ 行已经被更新了，因此升序枚举 $v$。\n沿用 01 背包的例子，改变 $v$ 的枚举顺序为升序：\n用 $1$ 号物品（$w_1=1,c_1=2$）更新 $f[0\\cdots 4]$：\n   $f\\setminus v$ $0$ $1$ $2$ $3$ $4$     $f$（上一行） $0$ $0$ $0$ $0$ $0$   更新 $f[0]$ $\\color{blue}{f[0]=0}$ $0$ $0$ $0$ $0$   更新 $f[1]$ $\\color{blue}{0}$ $\\color{blue}{f[1-1]}\\color{red}{+2}$ $0$ $0$ $0$   更新 $f[2]$ $0$ $\\color{blue}{2}$ $\\color{blue}{f[2-1]}\\color{red}{+2}$ $0$ $0$   更新 $f[3]$ $0$ $2$ $\\color{blue}{4}$ $\\color{blue}{f[3-1]}\\color{red}{+2}$ $0$   更新 $f[4]$ $0$ $2$ $4$ $\\color{blue}{6}$ $\\color{blue}{f[4-1]}\\color{red}{+2}$   $f$ $0$ $2$ $4$ $6$ $8$    for(int i = 1; i \u0026lt;= n; i ++) for(int v = w[i]; v \u0026lt;= m; v ++) f[v] = max(f[v], f[v - w[i]] + c[i]); 多重背包 $  如果 $n$ 种物品分别有 $s_1,s_2,\\cdots,s_n$ 个？\n第 $i$ 个物品有 $s_i+1$ 种策略（取 $0\\sim s_i$ 件）。在 01 背包的基础上，再枚举物品个数 $k$，每次绑定 $k$ 个物品当成一个物品。\n\r$$\rf[v] = \\max\\left\\{\\begin{aligned}\r\u0026f[v]\\\\\r\u0026f[v-k·w_i]+k·c_i,v≥k·w_i\r\\end{aligned}\\right.\r$$\r\r时间复杂度为 $O(m\\sum s_i)$。\nfor(int i = 1; i \u0026lt;= n; i ++) for(int v = m; v \u0026gt;= w[i]; v --) for(int k = 0; k \u0026lt;= s[i] \u0026amp;\u0026amp; v \u0026gt;= k * w[i]; k ++) f[v] = max(f[v], f[v - k * w[i]] + k * c[i]); 转换为 01 背包 $    在 $1,2,4,\\cdots,2^n$ 中选出若干个相加，可以得到 $0\\sim 2^{n+1}-1$ 中的任意整数。\n  同理，$1,2,4,\\cdots,2^k,n-(2^{k+1}-1)$ 可以组合出 $0\\sim n$ 中的任意整数，其中 $k$ 是满足 $n-(2^{k+1}-1)\u0026gt;0$ 的最大整数。\n  将第 $i$ 种物品拆分成 $\\log{s_i}$ 个物品，它们的体积和价值如下：\n   体积 $w$ $w_i$ $2w_i$ $4w_i$ $\\cdots$ $2^kw_i$ $[s_i-(2^{k+1}-1)]w_i$     价值 $v$ $c_i$ $2c_i$ $4c_i$ $\\cdots$ $2^kc_i$ $[s_i-(2^{k+1}-1)]c_i$    这些物品可以组合出第 $i$ 个物品的所有选择方案（取 $0\\sim s_i$ 件）。用 01 背包的策略处理出最佳选择方案。时间复杂度为 $O(m\\sum\\log{s_i})$\nInfo\n完全背包也可以用相同的方法进行优化。\n for(int i = 1; i \u0026lt;= n; i ++) { int wi, ci, si, k = 1; cin \u0026gt;\u0026gt; wi \u0026gt;\u0026gt; ci \u0026gt;\u0026gt; si; while(k \u0026lt;= si) { w[++ tot] = wi * k, c[tot] = ci * k; si -= k, k *= 2; } w[++ tot] = wi * si, c[tot] = ci * si; } for(int i = 1; i \u0026lt;= tot; i ++) for(int v = m; v \u0026gt;= w[i]; v --) f[v] = max(f[v], f[v - w[i]] + c[i]); 分组背包 $  给定 $t$ 组物品，第 $k$ 组有 $s_k$ 个物品，第 $k$ 组第 $i$ 个物品体积为 $w_{k \\ i}$，价值为 $c_{k \\ i}$。每组中的物品互相冲突，最多选一件。将哪些物品放入背包可使总价值最大？\n$f[k,v]$ 表示将前 $k$ 组的物品放入体积为 $v$ 的背包中，可以获得的最大总价值。\n第 $k$ 组的选择策略如下：\n\r$$\rf[k,v] = \\max\\left\\{\\begin{aligned}\r\u0026f[k-1,v]\\\\\r\u0026\\max_{1≤i≤s_k} \\ f[k-1,v-w_{k \\ i}]+c_{k \\ i},v≥w_{k \\ i}\r\\end{aligned}\\right.\r$$\r\r和 01 背包类似，同样可以省去一维。时间复杂度为 $O(nm)$。\n枚举第 $k$ 组物品的循环应放在最内层。若放在外层，则等价于 01 背包，失去了分组的意义。\nfor(int k = 1; k \u0026lt;= t; k ++) for(int v = m; v \u0026gt;= 0; v --) for(int i = 1; i \u0026lt;= s[k]; i ++) if(v \u0026gt;= w[k][i]) f[v] = max(f[v],f[v - w[k][i]] + c[k][i]); 二维背包 $  背包的体积为 $m_1$，承重为 $m_2$；物品个数为 $n$，第 $i$ 个物品的体积为 ${w_1}_i$，质量为 ${w_2}_i$，价值为 $c_i$。在背包不过载的同时，将哪些物品装入背包可使总价值最大？\n同时枚举体积和质量即可。\n\r$$\rf[v_1,v_2] = \\max\\left\\{\\begin{aligned}\r\u0026f[v_1,v_2]\\\\\r\u0026f[v_1-{w_1}_i,v_2-{w_2}_i]+c_i,v_1≥{w_1}_i,v_2≥{w_2}_i\r\\end{aligned}\\right.\r$$\r\r时间复杂度为 $O(nm_1m_2)$。\nfor(int i = 1; i \u0026lt;= n; i ++) for(int v1 = m1; v1 \u0026gt;= w1[i]; v1 --) for(int v2 = m2; v2 \u0026gt;= w2[i]; v2 --) f[v1][v2] = max(f[v1][v2], f[v1 - w1[i]][v2 - w2[i]] + c[i]); 拓展 $  方案总数 $  在 01 背包的基础上，将物品放入背包的方案有几种？\n$g[i,v]$ 表示把前 $i$ 个物品放入体积为 $v$ 的背包的方案总数。\n  若不放第 $i$ 个物品，则方案总数为 $g[i-1,v]$；\n  若放第 $i$ 个物品，则方案总数为 $g[i,v-w_i]$。\n  $$ g[i,v]=g[i-1,v]+g[i-1,v-w_i],v≥w_i $$\n同样可以省去第一维：\n$$ g[v]=g[v]+g[v-w_i],v≥w_i $$\n初始条件：$g[0]=1$。因为当背包体积为 $0$ 时只有一个方案：不装任何物品。\nfor(int i = 1; i \u0026lt;= n; i ++) for(int v = m; v \u0026gt;= w[i]; v --) g[v] += g[v - w[i]; 最优方案总数 $  使总价值最大的方案有几种？\n已知 01 背包的状态转移方程：\n\r$$\rf[i,v] = \\max\\left\\{\\begin{aligned}\r\u0026f[i-1,v]\\\\\r\u0026f[i-1,v-w_i]+c_i,v≥w_i\r\\end{aligned}\\right.\r$$\r\r$g[i,v]$ 表示把前 $i$ 个物品放入体积为 $v$ 的背包的方案总数。\n  若 $f[i-1,v]\u0026gt;f[i-1,v-w_i]+c_i$，不放物品 $i$ 总价值最大，$g[i,v]=g[i-1,v]$；\n  若 $f[i-1,v]\u0026lt;f[i-1,v-w_i]+c_i$，放物品 $i$ 总价值最大，$g[i,v]=g[i-1,v-w_i]$；\n  若相等，则放或不放都可使总价值最大，$g[i,v]=g[i-1,v]+g[i-1,v-w_i]$。\n  for(int i = 1; i \u0026lt;= n; i ++) { for(int v = 0; v \u0026lt; w[i]; v ++) f[i][v] = f[i - 1][v], g[i][v] = g[i - 1][v]; for(int v = m; v \u0026gt;= w[i]; v --) { f[i][v] = max(f[i - 1][v], f[i - 1][v - w[i]] + c[i]); if(f[i][v] == f[i - 1][v]) g[i][v] += g[i - 1][v]; if(f[i][v] == f[i - 1][v - w[i]] + c[i]) g[i][v] += g[v - w[i]]; } } 一维优化版：\nfor(int i = 1; i \u0026lt;= n; i ++) for(int v = m; v \u0026gt;= w[i]; v --) { int max_f = max(f[v], f[v - w[i]] + c[i]), max_g = 0; if(max_f == f[v]) max_g += g[v]; if(max_f == f[v - w[i]] + c[i]) max_g += g[v - w[i]]; f[v] = max_f, g[v] = max_g; } "}),a.add({id:29,href:'/docs/String/AC-atm/',title:"AC 自动机",section:"字符串",content:"void build() { for(int i = 0; i \u0026lt; 26; i ++) if(tr[0][i]) q.push(tr[0][i]); while(q.size()) { int u = q.front(); q.pop(); for(int i = 0; i \u0026lt; 26; i ++) if(tr[u][i]) fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]); else tr[u][i] = tr[fail[u]][i]; } } void insert(char *s) { int u = 0; for(int i = 1; s[i]; i ++) { if(!tr[u][s[i] - \u0026#39;a\u0026#39;]) tr[u][s[i] - \u0026#39;a\u0026#39;] = ++ tot; u = tr[u][s[i] - \u0026#39;a\u0026#39;]; } e[u]++; } int query(char *t) { int u = 0, res = 0; for(int i = 1; t[i]; i ++) { u = tr[u][t[i] - \u0026#39;a\u0026#39;]; for(int j = u; j \u0026amp;\u0026amp; e[j] != -1; j = fail[j]) res += e[j], e[j] = -1; } return res; } "}),a.add({id:30,href:'/docs/DP/interval/',title:"区间 DP",section:"动态规划",content:"引出问题 $  $n$ 堆石子排成一列，第 $i$ 堆石子重量为 $A_i$。每次合并相邻两堆石子为一堆，消耗的体力值为这两堆石子的重量和。求将所有石子合并为一堆，最少消耗多少体力。\n基本原理 $  $f[l,r]$ 表示合并区间 $[l,r]$ 内的石子（第 $l$ 堆至第 $r$ 堆石子）花费的最少体力值。\n枚举 $k=l→r-1$：\n  合并区间 $[l,k]$ 内的石子为一堆石子，消耗体力值 $f[l,k]$；\n  合并区间 $[k+1,r]$ 内的石子为一堆石子，消耗体力值 $f[k+1,r]$；\n  合并剩下两堆石子，消耗体力值 $A_l+A_{l+1}+\\cdots+A_r$。\n  $$ f[l,r]=\\min_{l≤k\u0026lt;r}{f[l,k]+f[k+1,r]}+\\sum_{i=l}^r A_i $$\n使用 前缀和 进一步优化查询区间石子质量和的效率：\n$$ f[l,r]=\\min_{l≤k\u0026lt;r}{f[l,k]+f[k+1,r]}+sum[r]-sum[l-1] $$\n由于大区间的「最少体力值」由小区间推出，故计算顺序为从小区间到大区间。\n枚举区间长度 $len=2→n$，每次计算所有长度为 $len$ 的区间的「最少体力值」。\n   初始条件 $f[i,i]=0$，其余为 $∞$ 计算顺序 $f[$小区间$]→f[$大区间$]$     最终答案 $f[1,n]$ 时间复杂度 $O(n^3)$    \r.th {\rfont-weight: normal;\r}\r\rmemset(f, 0x7f, sizeof f); for(int i = 1; i \u0026lt;= n; i ++) { f[i][i] = 0; sum[i] = sum[i - 1] + a[i]; } for(int len = 2; len \u0026lt;= n; len ++) // 区间长度  for(int l = 1; l + len - 1 \u0026lt;= n; l ++) { // 枚举区间左端点  int r = l + len - 1; // 区间右端点  for(int k = l; k \u0026lt; r; k ++) f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]); f[l][r] += sum[r] - sum[l - 1]; } "}),a.add({id:31,href:'/docs/DS/DSU/',title:"并查集",section:"数据结构",content:'简介 $  并查集 支持以下操作：\n  往一个集合中加入元素；\n  快速查询两个元素是否在同一集合；\n  合并两个集合为一个集合。\n  基本原理 $  若 $a \\ b$，$e \\ c$，$e \\ d$ 分别在同一个集合，则一共有几个集合？$b$ 和 $d$ 是否同集？\n构造并查集 $  把属于同一集合的两个节点连一起，易知集合数 $=$ 连通图数。若两个节点连通，则它们同集。\n并查集在每个集合中选取一个代表元素作为根节点，构造「树型结构」。如下图，$a$ 和 $e$ 分别是两个集合的代表元素。\n mermaid.initialize({ "flowchart": { "useMaxWidth":true }, "theme": "default" } ) flowchart TD\rsubgraph \u0026nbsp\re((e))--c((c))\re((e))--d((d))\rend\rsubgraph \u0026nbsp\ra((a))--b((b)) end\r$fa[i]$ 代表节点 $i$ 的父节点编号。如上图，$fa[b]=a$，$fa[d]=e$，$fa[c]=e$。根节点没有父节点，其 $fa$ 值都设为 $0$，如 $fa[a]=0$，$fa[e]=0$。\n查询代表元素 $  集合的代表元素就是并查集中的根节点。若节点 $x$ 没有父节点，则它自己是根节点，否则递归查询它的父节点。时间复杂度为 $O(\\log{n})$。\nint find(int x) { // 返回节点 x 的根节点  if(!fa[x]) return x; return find(fa[x]); } 查询是否同集 $  若两个节点的根节点相同，则它们同集。\nbool judge(int x, int y) { return find(x) == find(y); } 合并集合 $  若 $b$ 和 $c$ 也属于同一集合，则合并 $b$ 和 $c$ 所在的集合。已知 $b$ 和 $c$ 的根节点分别为 $a$ 和 $e$，那么新建一条从 $a$ 连向 $e$ 的边，即 $fa[e]=a$。\nflowchart TD\rsubgraph \u0026nbsp\re((e))--c((c))\re((e))--d((d))\rend\rsubgraph \u0026nbsp\ra((a))--b((b)) end\ra---e\rvoid merge(int x, int y) { if(find(x) != find(y)) // 如果节点 x 和 y 已经同集，则没必要再合并  find(x) = fa[find(y)]; } 路径压缩 $    每次查询出节点 $i$ 所在集合的根节点 $e$ 后，使 $fa[i]=e$；\n  再次查询 $i$ 的根节点时，find(i) 函数就会直接返回 $e$，免去递归过程。\n  时间复杂度被优化为 $O(1)$。该做法类似于记忆化搜索。\nint find(int x) { if(!fa[x]) return x; return fa[x] = find(fa[x]); // 最后两行等价于 { fa[x] = find(fa[x]); return fa[x]; } } '}),a.add({id:32,href:'/docs/Graph/SCC/',title:"强连通分量",section:"图论",content:"Tarjan 算法 $  int dep[], low[], tot; stack\u0026lt;int\u0026gt; s; void tarjan(int u) { dep[u] = low[u] = ++ tot; s.push(u), avl[u] = true; for(int i = 0; i \u0026lt; g[u].size(); i ++) { int y = g[u][i]; if(!dep[y]) { tarjan(y); low[u] = min(low[u], low[y]); } else if(avl[y]) low[u] = min(low[u], dep[y]); } if(dep[u] == low[u]) { ans ++; while(u != s.top()) avl[s.top()] = false, s.pop(); avl[u] = false, s.pop(); } } Kosaraju 算法 $  void dfs1(int u) { vis[u] = true; for(int v : g[u]) if(!vis[v]) dfs1(v); s.push_back(u); } void dfs2(int u) { color[u] = sccCnt; for(int v : g2[u]) if(!color[v]) dfs2(v); } void kosaraju() { sccCnt = 0; for(int i = 1; i \u0026lt;= n; ++i) if(!vis[i]) dfs1(i); for(int i = n; i \u0026gt;= 1; --i) if(!color[s[i]]) { ++ sccCnt; dfs2(s[i]); } } Garbow 算法 $  int garbow(int u) { stack1[++p1] = u; stack2[++p2] = u; low[u] = ++dfs_clock; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (!low[v]) garbow(v); else if (!sccno[v]) while (low[stack2[p2]] \u0026gt; low[v]) p2--; } if (stack2[p2] == u) { p2--; scc_cnt++; do { sccno[stack1[p1]] = scc_cnt; } while (stack1[p1--] != u); } return 0; } void find_scc(int n) { dfs_clock = scc_cnt = 0; p1 = p2 = 0; memset(sccno, 0, sizeof(sccno)); memset(low, 0, sizeof(low)); for (int i = 1; i \u0026lt;= n; i++) if (!low[i]) garbow(i); } "}),a.add({id:33,href:'/docs/Basics/zip/',title:"状态压缩",section:"基础算法",content:"简介 $  将长度为 $m$ 的 $bool$ 数组用一个 $m$ 位二进制整数表示，该整数的第 $i$ 位对应原数组第 $i$ 个元素。\n\r   操作 运算     取出二进制数 $n$ 的第 $k$ 位 (n \u0026gt;\u0026gt; (k - 1)) \u0026amp; 1   将二进制数 $n$ 的第 $k$ 位取反 n ^ (1 \u0026lt;\u0026lt; (k - 1))   将二进制数 $n$ 的第 $k$ 位赋值为 $1$ n | (1 \u0026lt;\u0026lt; (k - 1))   将二进制数 $n$ 的第 $k$ 位赋值为 $0$ n \u0026amp; (~(1 \u0026lt;\u0026lt; (k - 1)))    可以直接使用 STL Bitset。\nLowbit 运算 $  $lowbit(n)$ 为 $n$ 在二进制表示下「最低位的 $1$ 和其后所有的 $0$」构成的数。例如 $n=(101000)_2$，$lowbit(n)=(1000)_2$。\n$n[i]$：$n$ 在二进制表示下的第 $i$ 位数字。假设 $n[k]=1$，$n[0\\cdots k-1]=0$。\n  将 $n$ 的每一位取反，即 $n=\\sim n$，此时 $n[k]=0$，$n[0\\cdots k-1]=1$，其它位和原来相反；\n  令 $n=n+1$，此时 $n[k]=1$，$n[0\\cdots k-1]=0$，其它位仍和原来相反；\n  因此 $n\\\u0026amp;(\\sim n+1)$ 仅有第 $k$ 位为 $1$。\n  由于在补码表示下 $-n=\\sim n+1$，因此：\n\r$$\rlowbit(n)=n\\\u0026(\\sim n+1)=n\\\u0026-n\r$$\r\r时间复杂度为 $O(1)$。结合样例理解。\n   $n$ $\\sim n$ $\\sim n+1$ $n\\\u0026amp;(\\sim n+1)$     $($101000$)_2$ $($010111$)_2$ $($011000$)_2$ $($001000$)_2$   $($101100$)_2$ $($010011$)_2$ $($010100$)_2$ $($000100$)_2$    "}),a.add({id:34,href:'/docs/Graph/treap/',title:"Treap 平衡树",section:"图论",content:"long m,n,tot=0,root;; long a[30010]; long fa[30010],left[30010],right[30010],data[30010],key[30010],size[30010]; void Init() { long i; scanf(\u0026#34;%ld%ld\u0026#34;,\u0026amp;m,\u0026amp;n); for(i=1; i\u0026lt;=m; i++) scanf(\u0026#34;%ld\u0026#34;,\u0026amp;a[i]); } void Rotate(long x) { long y,z; y=fa[x]; z=fa[y]; fa[x]=z; fa[y]=x; if(x==left[y]) { fa[right[x]]=y; left[y]=right[x]; right[x]=y; } else { fa[left[x]]=y; right[y]=left[x]; left[x]=y; } if(y==left[z]) left[z]=x; else right[z]=x; size[y]=size[left[y]]+size[right[y]]+1; size[x]=size[left[x]]+size[right[x]]+1; if(y==root) root=x; } void Insert(long x) { long p,q; if(tot==0) { tot++; root=tot; fa[tot]=left[tot]=right[tot]=0; data[tot]=x; key[tot]=rand()+rand()+rand(); size[tot]=1; return; } p=root; while(1) { q=p; size[q]++; if(data[q]\u0026lt;=x) p=right[q]; else p=left[q]; if(p==0) break; } tot++; fa[tot]=q; left[tot]=right[tot]=0; data[tot]=x; size[tot]=1; key[tot]=rand()+rand()+rand(); if(data[q]\u0026lt;=x) right[q]=tot; else left[q]=tot; p=tot; while(key[p]\u0026gt;key[fa[p]]) Rotate(p); } long Find(long x) { long p=root; while(1) { if(size[left[p]]+1==x) return data[p]; if(size[left[p]]+1\u0026lt;x) { x=x-size[left[p]]-1; p=right[p]; } else p=left[p]; } } void Work() { long i,j,x,now=0; key[0]=2147483647; for(i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%ld\u0026#34;,\u0026amp;x); for(j=now+1; j\u0026lt;=x; j++) Insert(a[j]); now=x; printf(\u0026#34;%ld\\n\u0026#34;,Find(i)); } } "}),a.add({id:35,href:'/docs/DP/digit/',title:"数位 DP",section:"动态规划",content:"简介 $  如何统计区间 $[l,r]$ 中有多少整数符合某条件？\n  暴力算法，枚举 $[l,r]$ 中的每一个整数，逐个判断是否满足条件，此方法遇大数据必 $gg$。\n  优雅地使用数位 DP。\n  引出问题 $  统计区间 $[l,r]$（$0≤l\u0026lt;r≤100$）中有多少整数符合「相邻两个数字之差 $≥2$」。\n预处理 $  采用「试填法」：从个位填到最高位，如果第 $d$ 位填了 $i$，那么第 $d+1$ 位只能填 $[0,i-1]$ 或 $[i+1,9]$ 中的整数。\n$f[i,d]$ 表示「所有最高位为 $i$ 的 $d$ 位数中，符合条件的个数」。通过给定条件可推出：\n$$ f[i,d]=\\sum_{|k-i|≥2} f[k,d-1] $$\n   初始条件 $f[i,1]=1$ 计算顺序 $f[0→9,2→n]$     时间复杂度 $O(10^2\\log{n})$      int f[][]; for(int i = 0; i \u0026lt;= 9; i ++) f[i][1] = 1; // 初始条件 for(int d = 2; d \u0026lt;= N; d ++) // N : 位数的上限，N ≈ log(r) 	for(int i = 0; i \u0026lt;= 9; i ++) for(int k = 0; k \u0026lt;= 9; k ++) if(abs(k - i) \u0026gt;= 2) f[i][d] += f[k][d - 1]; 数位统计 $  考虑 前缀和 思想：\n$dp(n)$ 表示 $[0,n]$ 中有多少个数满足条件。$[l,r]$ 中符合条件的个数 $=dp(r)-dp(l-1)$。\n$dp(n)$ 的实现步骤：\n  提取 $n$ 每一位上的数字，存入数组 $at[ \\ ]$：\nint cap = 0, at[]; // cap : n 的位数；at[i] : n 的第 i 位数字 while(n) at[++ cap] = n % 10, n /= 10;   所有 $1\\cdots cap-1$ 位数都被包含于 $[0,n]$ 区间中。统计它们中符合条件的个数：\nint ans = 0; // ans : 符合条件的个数 for(int d = 1; d \u0026lt; cap; d ++) // d : 位数  for(int i = 1; i \u0026lt;= 9; i ++) // i : 最高位填的数  ans += f[i][d];   统计所有 $cap$ 位数中符合条件的个数。\n使用「试填法」，枚举 $d=cap→1$，从最高位填到最低位，并使填的数 $\u0026lt;n$：\n  若 $d=cap$，该位不能填 $0$，只能填 $1\\cdots at[d]-1$。统计符合条件的情况；\n  若 $d≠cap$，该位只能填 $0\\cdots at[d]-1$。统计符合条件的情况；\n 若此时 $|at[d+1]-at[d]|\u0026lt;2$，下一位无论怎么填都不符合条件，跳出循环；    若上一步未跳出循环且 $d=1$，说明 $n$ 本身也符合条件。但「试填法」最多只填到 $n-1$，故还要多算一个。\n  for(int d = cap; d \u0026gt;= 1; d --) { // d : 当前填到第 d 位  for(int i = (d == cap); i \u0026lt; at[d]; i ++) if(abs(at[d + 1] - i) \u0026gt;= 2) ans += f[i][d]; if(d != cap \u0026amp;\u0026amp; abs(at[d + 1] - at[d]) \u0026lt; 2) break; if(d == 1) ans ++; }   模板 $  int dp(int n) { // 求 [0, n] 中有几个数符合条件  if(n \u0026lt;= 0) return !n; // 特判  int cap = 0, ans = 0, at[]; while(n) at[++ cap] = n % 10, n /= 10; for(int d = 1; d \u0026lt; cap; d ++) for(int i = 1; i \u0026lt;= 9; i ++) ans += f[i][d]; for(int d = cap; d \u0026gt;= 1; d --) { for(int i = (d == cap); i \u0026lt; at[d]; i ++) if(abs(last - i) \u0026gt;= 2) ans += f[i][d]; // 条件按照题目的需要  if(d != cap \u0026amp;\u0026amp; abs(at[d + 1] - at[d]) \u0026lt; 2) break; if(d == 1) ans ++; } return ++ ans; } "}),a.add({id:36,href:'/docs/DS/treearray/',title:"树状数组",section:"数据结构",content:"前置知识 $  你得先学会 $lowbit(n)$ 的计算方式。\n引入问题 $  数组 $A$ 中共 $n$ 个元素，对其反复进行以下操作共 $m$ 次：\n  单点修改：将 $A[ x]$ 加上 $k$。\n  区间查询：查询 $A[l\\cdots r]$ 的和。\n  int a[]; void set(int id, int v) { // 单点修改  a[id] = v; } int ask(int l, int r) { // 区间查询  int ans = 0; for(int i = l; i \u0026lt;= r; i ++) ans += a[i]; return ans; }     暴力算法（$\\textcolor{red}{×}$） 树状数组（$\\textcolor{green}{√}$）     单点修改 $\\textcolor{green}{O(1)}$ $\\textcolor{green}{O(\\log{n})}$   区间查询 $\\textcolor{red}{O(n)}$ $\\textcolor{green}{O(\\log{n})}$   $m$ 次操作 $\\textcolor{red}{O(mn)}$ $\\textcolor{green}{O(m\\log{n})}$    构造 $  在原数组的上方构建树型结构，每个节点表示一段区间和：\n\r$C_1=A_1$；\n$C_2=A_1+A_2$；\n$C_3=A_3$；\n$C_4=A_1+A_2+A_3+A_4$；\n$\\cdots \\ \\cdots$\n父节点 $  如何求 $C_i$ 的父节点？\n将 $C$ 数组的下标转换成二进制数，观察该图。\n\r  $C[$0001$]$ 的父节点为 $C[$0010$]$。\n  $C[$0100$]$ 的父节点为 $C[$1000$]$。\n  $C[$0101$]$ 的父节点为 $C[$0110$]$。\n$\\cdots \\ \\cdots$\n  不难总结出规律：\n $C_i$ 的父节点为 $C[i+$ $lowbit(i)$ $]$。  左邻节点 $  $C_i$ 的「左邻节点」与 $C_i$ 的左端相邻。例如 $C_5$ 的左邻节点为 $C_4$。\n\r观察同一张图：\n\r  $C[$0011$]$ 的左邻节点为 $C[$0010$]$。\n  $C[$0101$]$ 的左邻节点为 $C[$0100$]$。\n  $C[$0110$]$ 的左邻节点为 $C[$0100$]$。\n  总结规律：\n $C_i$ 的左邻节点为 $C[i-lowbit(i)]$。  单点修改 $  将 $A[x]$ 增加 $k$，$A[x]$ 的所有祖先都会跟着变动。以 $A_3$ 为例：\n\r$C_3=\\textcolor{red}{A_3}$；\n$C_4=A_1+A_2+\\textcolor{red}{A_3}+A_4$；\n$C_8=A_1+A_2+\\textcolor{red}{A_3}+A_4+A_5+A_6+A_7+A_8$。\n因此，修改 $A[3]$ 的同时，$C_3,C_4,C_8$ 也需要加上 $k$。\n对于给定的 $x$，从 $C_x$ 开始逐层访问 父节点，并给其值加上 $k$。时间复杂度为 $O(\\log{n})$。\nint lowbit(int x) { return x \u0026amp; -x; } void add(int p, int k) { // 将 a[p] 增加 k  for(; p \u0026lt;= n; p += lowbit(p)) c[p] += k; } 区间查询 $  采用 前缀和 思想。$sum[x]$ 表示 $A[1]+A[2]+\\cdots+A[x]$，则：\n$A[l\\cdots r]$ 的和 $=sum[r]-sum[l-1]$\r自此，问题转换为求 $sum[x]$。以 $sum[7]$ 为例：\n\r$C_4=A_1+A_2+A_3+A_4$；\n$C_6=A_5+A_6$；\n$C_7=A_7$；\n因而 $sum[7]=C_4+C_6+C_7$。\n查询 $sum[x]$ 时，从 $C_x$ 开始依次遍历 左邻节点。时间复杂度为 $O(\\log{n})$。\nint ask(int p) { // 查询 A[1...p] 的和  int sum = 0; for(; p; p -= lowbit(p)) sum += c[p]; return sum; } int get(int l, int r) { // 查询 A[l...r] 的和  return ask(r) - ask(l - 1); } 模板 $  int lowbit(int x) { return x \u0026amp; -x; } void add(int p, int k) { for(; p \u0026lt;= n; p += lowbit(p)) c[p] += k; } int ask(int p) { int sum = 0; for(; p; p -= lowbit(p)) sum += c[p]; return sum; } int get(int l, int r) { return ask(r) - ask(l - 1); } 拓展 $  区间修改 $  如果你已经学过 差分，区间修改就容易的多。\n  在数组 $A$ 的「差分数组」上建立树状数组。\n  将 $A[l\\cdots r]$ 所有元素都加上 $v$ 时，$f[l]$ 增加了 $v$，$f[r+1]$ 减少了 $v$。\n  void seg_add(int l, int r, int v) { // 将 A[l...r] 加上 v  add(l, v); add(r + 1, -v); } int main() { /* 输入部分省略 */ for(int i = 1; i \u0026lt;= n; i ++) { add(i, a[i] - a[i - 1]); } } "}),a.add({id:37,href:'/docs/Basics/hipre/',title:"高精度",section:"基础算法",content:"简介 $  高精度是一套支持高位数的运算系统，例如求两个 114514 位数的和。\n输入 $  先输入字符串，再把每一位取出，存入数组。\nvoid init(int a[]) { memset(a, 0, sizeof a); // 清空数组 a  string s; cin \u0026gt;\u0026gt; s; a[0] = s.length(); // a[0] 用于储存数的长度  for(int i = 1; i \u0026lt;= a[0]; i ++) a[i] = s[a[0] - i] - \u0026#39;0\u0026#39;; // 将字符串倒序储存，便于按位计算 } 也可以逐个读入字符。\nvoid init(int a[]) { memset(a, 0, sizeof a); int i = 0; char s = getchar(); while(s \u0026lt; \u0026#39;0\u0026#39; || s \u0026gt; \u0026#39;9\u0026#39;) s = getchar(); while(s \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s \u0026lt;= \u0026#39;9\u0026#39;) a[++ i] = s – \u0026#39;0\u0026#39;, s = getchar(); a[0] = i; } 比较 $  先比较位数，若位数相同则从高位到低位逐位比较。\nint cmp(int a[], int b[]) { // a \u0026gt; b 则返回 1，a \u0026lt; b 则返回 -1，否则返回 0  if(a[0] != b[0]) return a[0] \u0026gt; b[0] ? 1 : -1; for(int i = a[0]; i \u0026gt;= 1; i --) if(a[i] != b[i]) return a[i] \u0026gt; b[i] ? 1 : -1; return 0; } 高精度加法 $  从个位开始，将两个数对应位置的数字相加，超过 $10$ 要进位。\nvoid plus(int a[], int b[], int c[]) { // 将 a + b 的结果存入 c  memset(c, 0, sizeof c); c[0] = max(a[0], b[0]); for(int i = 1; i \u0026lt;= c[0]; i ++) { c[i] += a[i] + b[i]; if(c[i] \u0026gt;= 10) // 进 1  c[i + 1] += 1, c[i] %= 10; } while(c[c[0] + 1] != 0) c[0] ++; // 修正位数 } 高精度减法 $  从个位开始，将两个数对应位置的数字相减，小于 $0$ 要借位。\nvoid minus(int a[], int b[], int c[]) { // 将 a - b 的结果存入 c  memset(c, 0, sizeof c); c[0] = max(a[0], b[0]); for(int i = 1; i \u0026lt;= c[0]; i ++) { if(a[i] \u0026lt; b[i]) // 借位  a[i + 1] --, a[i] += 10; c[i] = a[i] - b[i]; } while(c[c[0]] == 0 \u0026amp;\u0026amp; c[0] \u0026gt;= 1) c[0] --; // 修正位数 } 高精度乘法 $  高精 × 低精 $  从个位开始，将高精度数的每一位乘以低精度数，超过 $10$ 要进位。\nWarning\n高精度乘法的进位可能非常大，按位乘完后还要处理多余的进位。\n void mult(int a[], int b, int c[]) { // 将 a × b 的结果存入 c  memset(c, 0, sizeof c); c[0] = a[0]; for(int i = 1; i \u0026lt;= a[0]; i ++) { c[i] += a[i] * b; if(c[i] \u0026gt;= 10) c[i + 1] += c[i] / 10, c[i] /= 10; } while(c[c[0] + 1]) // 处理多余的进位  c[c[0] + 1] += c[c[0]] / 10, c[c[0]] /= 10, c[0] ++; } 高精 × 高精 $  做竖式乘法时，$a$ 的第 $i$ 位乘 $b$ 的第 $j$ 位最终会加在答案的第 $i+j-1$ 位上。\n\rWarning\n计算结束后要去掉最高位多余的 $0$。\n void mult(int a[], int b[], int c[]) { // 将 a × b 的结果存入 c  memset(c, 0, sizeof c); c[0] = a[0] + b[0]; int d; // 用于存放进位  for(int i = 1; i \u0026lt;= a[0]; i ++) { d = 0; for(int j = 1; j \u0026lt;= b[0]; j ++) { c[i + j - 1] += a[i] * b[j] + d; d = c[i + j - 1] / 10, c[i + j - 1] %= 10; } c[i + b[0]] = d; // 多余的进位  } while(c[c[0]] == 0 \u0026amp;\u0026amp; c[0] \u0026gt; 1) c[0] --; // 去掉最高位多余的 0 } 高精度除法 $  做竖式除法时，将除数的最高位和被除数对齐，逐位「试商」，如下图（空位已用 $0$ 填补）：\n\r高精度除法步骤：\n  将除数的最高位和被除数对齐；\n  将被除数一直减去除数，直到被除数 \u0026lt; 除数，记录减的次数；\n  重复上两步，直到除到个位；\n  按顺序输出减的次数，得到整个式子的商。最后的被除数是余数。\n  Warning\n  计算结束后要去掉最高位多余的 $0$。\n  样例程序的 $dev()$ 函数执行结束后，数组 $a$ 存储的数变为 $a÷b$ 的余数。\n   void shift(int a[], int d) { // 在 a 的后面补 d 个 0（若 d \u0026lt; 0 则去掉|d|个 0）  int b[100001] = {}; for(int i = a[0] + d; i \u0026gt;= max(0, 1 + d); i --) b[i] = a[i - d]; a[0] += d; for(int i = 1; i \u0026lt;= max(a[0], a[0] - d); i ++) a[i] = b[i]; } void dev(int a[], int b[], int c[]) { // 将 a ÷ b 的结果存入 c  memset(c, 0, sizeof c); if(b[0] == 1 \u0026amp;\u0026amp; b[1] == 0) return; // 除数为 0 时无意义  if(cmp(a, b) == -1) { // 被除数 \u0026lt; 除数时，商为 0  c[0] = 1, c[1] = 0; return; } c[0] = a[0] - b[0] + 1; shift(b, a[0] - b[0]); // 调整 b 的位数，使 b 和 a 对齐  for(int i = c[0]; i \u0026gt;= 1; i --) { while(cmp(a, b) \u0026gt;= 0) { // 用高精度减法模拟「试商」  c[i] ++; for(int j = 1; j \u0026lt;= a[0]; j ++) { if(a[j] \u0026lt; b[j]) a[j + 1] --, a[j] += 10; a[j] -= b[j]; } while(a[a[0]] == 0 \u0026amp;\u0026amp; a[0] \u0026gt; 1) a[0] --; // 去掉最高位多余的 0  } shift(b, -1); // 将 b 减小一位，和新的被除数对齐  } while(c[c[0]] == 0 \u0026amp;\u0026amp; c[0] \u0026gt; 1) c[0]--; // 去掉最高位多余的 0 } 输出 $  数据是倒序储存的，故倒序输出：\nvoid print(int a[]) { for(int i = a[0]; i \u0026gt;= 1; i --) printf(\u0026#34;%d\u0026#34;, a[i]); printf(\u0026#34;\\n\u0026#34;); } "}),a.add({id:38,href:'/docs/Tools/',title:"工具",section:"Docs",content:"OJ FFF OJ  洛谷 OJ  长乐 OJ  杭电 OJ  ACWing  CodeForces  LeetCode  Libre OJ  OpenJudge     工具 Cube  Generals  OI Wiki  Visu Algo      下载 BatToExe  Dev-C++  Enigma Box  Git  Lemon  MsiToExe  Node.js  OCam  Python  ResHacker  Swf Player  VSCode  WinRAR    "}),a.add({id:39,href:'/docs/DP/tree/',title:"树形 DP",section:"动态规划",content:'简介 $  树形 DP 所解决的问题基于「树形结构」。例如：给出一个家族的族谱，求任意两个成员的公共祖先。这里的族谱就是一种「树形结构」。\n\r引出问题 $  给定一棵 $n$ 个点，$m$ 条边，顶点编号为 $1\\sim n$ 的无权树，$1$ 号节点为根。以 $i$ 号节点为根的子树有几个节点？\n基本原理 $  $f[i]$ 表示以节点 $i$ 为根的子树大小，$Son(i)$ 表示 $i$ 的子节点集合。易知：\n$$ f[i]=1+\\sum_{v\\in Son(i)}f[v] $$\n$f[i]$ 由 $f[i$ 的子节点$]$ 推出，计算顺序应为 $f[$子节点$]→f[$父节点]。使用记忆化搜索。\nvector\u0026lt;int\u0026gt; son[]; // son[u] : 节点 u 的子节点集合  void dfs(int u) { // 求以 u 为根的子树中节点个数  f[u] = 1; for(int i = 0; i \u0026lt; son[u].size(); i ++) { int v = son[u][i]; // 节点 u 的第 i 个子节点  dfs(v); f[u] += f[v]; } } 例题 $  没有上司的舞会 $  公司有 $n$ 个人（编号 $1\\cdots n$），现要举⾏⼀场晚会，并规定如果邀请了某个⼈，那么⼀定不会邀请他的上司（他上司的上司，上司的上司的上司 $\\cdots$ 都可以邀请）。\n每个⼈都有⼀个欢乐值，给出公司所有人的上下级关系，求⼀个邀请⽅案，使欢乐值的和最⼤。\n$f[i,j]$ 表示从以 $i$ 为根的子树中邀请部分职员参会的最欢乐值之和，当 $j=0$ 时 $i$ 号员工不参会，$j=1$ 时参会。\n  若 $i$ 号员工的下属 $v$ 不参会，则总欢乐值为 $f[v,0]$；\n  若 $i$ 号员工的下属 $v$ 参会，则总欢乐值为 $f[v,1]$。\n  显然，若 $i$ 号员工参会，他的直接下属必不来：\n$$f[i,1]=H_i+\\sum_{v\\in Son(i)}f[v,0]$$\n若 $i$ 号员工参会，他的直接下属爱来不来：\n$$f[i,0]=\\sum_{v\\in Son(i)}\\max{f[v,0],f[v,1]}$$\nvoid dfs(int u) { // 求出 u 号员工对应的 f[u][0] 和 f[u][1]  f[u][1] = h[u]; for(v = u 的每个子节点) { dfs(v); f[u][1] += f[v][0]; f[u][0] += max(f[v][0], f[v][1]); } } 树形 DP + 背包 DP $  处理某些问题时，需要结合树形 DP 和 背包 DP 的思想。\n现有 $n$ 门课程，第 $i$ 门课程的学分为 $s_i$，每门课程有 $0$ 或 $1$ 门先修课。有先修课的课程需要先学完先修课，才能学习该课程。求学习 $m$ 门课程能获得的最多学分。\n将每门课程看作树中的节点，$a→b$ 代表 $a$ 比 $b$ 先修：\n mermaid.initialize({ "flowchart": { "useMaxWidth":true }, "theme": "default" } ) graph TB\r2((2))--1((1))\r2((2))--4((4))\r2((2))--7((7))\r7((7))--5((5))\r7((7))--6((6))\r3((3))\r为了方便解决问题，新增 $0$ 号节点，使其指向所有无先修课的课程：\ngraph TB\r0((0))--2((2))\r0((0))--3((3))\r2((2))--1((1))\r2((2))--4((4))\r2((2))--7((7))\r7((7))--5((5))\r7((7))--6((6))\r3((3))\r$f[u,j]$ 表示以 $u$ 为根节点，选 $j$ 个节点，获得的最大学分。\n$dfs(u)$ 的功能是算出以 $u$ 为根节点时，分别选 $0\\sim m$ 个节点时能获得的最大学分。\n执行 $dfs(u)$ 时，枚举 $u$ 的子节点 $v$，在内层循环枚举选取的节点数 $j=m→1$：\n  将 $j$ 个节点分成两组，一组 $k$ 个，另一组 $j-k$ 个；\n  将第一组 $k$ 个节点放在以 $v$ 为根节点的子树中，最大学分为 $f[v][k]$；\n  将第二组 $j-k$ 个节点放在以 $u$ 为根节点的子树中，但不放在以 $v$ 为根节点的子树中，最大学分为 $f[u][j-k]$。\n  $$ f[u,j]=\\max_{v\\in Son(u)}{f[u,j],f[u,j-k]+f[v,k]} $$\n   初始条件 $f[i,1]=s[i]$ 边界条件 $f[0,m]$     时间复杂度 $O(n^3)$      在主程序中执行 $dfs(0)$ 后输出 $f[0,m]$ 即可。\nvoid dfs(int u) { f[u][1] = s[u]; for(int i = 0; i \u0026lt; son[u].size(); i ++) { int v = son[u][i]; dfs(v); for(int j = m; j \u0026gt;= 1; j --) for(int k = j - 1; k \u0026gt; 0; k --) f[u][j] = max(f[u][j], f[v][k] + f[u][j - k]); } } '}),a.add({id:40,href:'/docs/DS/segtree/',title:"线段树",section:"数据结构",content:"引入问题 $  数组 $A$ 中共 $n$ 个元素，对其反复进行以下操作共 $m$ 次：\n  单点修改：将 $A[id]$ 修改为 $v$。\n  区间查询：查询 $A[l\\cdots r]$ 的最小值。\n  区间修改：将 $A[l\\cdots r]$ 每个数加上 $v$。\n  int a[]; void set(int id, int v) { // 单点修改  a[id] = v; } int ask(int l, int r) { // 区间查询  int ans = 0; for(int i = l; i \u0026lt;= r; i ++) ans = min(ans, a[i]); return ans; } void add(int l, int r, int v) { // 区间修改  for(int i = l; i \u0026lt;= r; i ++) a[i] += v; }     暴力算法（$\\textcolor{red}{×}$） 线段树（$\\textcolor{green}{√}$）     单点修改 $\\textcolor{green}{O(1)}$ $\\textcolor{green}{O(\\log{n})}$   区间查询 $\\textcolor{red}{O(n)}$ $\\textcolor{green}{O(\\log{n})}$   区间修改 $\\textcolor{red}{O(n)}$ $\\textcolor{green}{O(\\log{n})}$   $m$ 次操作 $\\textcolor{red}{O(mn)}$ $\\textcolor{green}{O(m\\log{n})}$    构造 $  查询数组 $A={6,2,3,7,1,5,4,2}$ 中的最小值时，通常使用「两两比较法」：每次比较相邻两项，只保留更小的一项。比较的过程可以画成一棵二叉树，树根是答案。\n\r这么做又有什么好处呢？假如数列中的 $1$ 被改为 $7$，你可以通过修改极少的数值，重新得出正确答案。\n\r线段树就是这样的一颗二叉树，它的每个节点都代表一段区间中的最小值。$u$ 号节点的信息储存于 $t[u]$。\n线段树具有以下性质：\n  根节点为 $t[1]$，代表整个数组的最小值。\n  $t[u]$ 的左子节点为 $t[2u]$，右子节点为 $t[2u+1]$。\n  $t[u]=\\min(t[2u],t[2u+1])$。\n  \r因此，每个节点需要保存以下信息：\n  节点的值：$val$。\n  节点代表的区间：$[l,r]$。\n  从根节点开始，自顶向下递归构建线段树。时间复杂度为 $O(n\\log{n})$。\nstruct Node { int val, l, r; #define t(u) t[u].val  #define l(u) t[u].l  #define r(u) t[u].r } t[]; void build(int u, int l, int r) { l(u) = l, r(u) = r; if(l == r) { // 当前节点为叶节点  t(u) = a[l]; return; } int m = (l + r) / 2; build(2 * u, l, m); // 递归构建左子树  build(2 * u + 1, m + 1, r); // 递归构建右子树  t(u) = min(t(2 * u), t(2 * u + 1)); } 单点修改 $  假设你要将 $A[5]$ 修改为 $3$，则 $A[5]$ 的所有祖先都有可能变动。\n\r$set(u,id,v)$：令 $A[id]=v$，并从节点 $u$ 开始，向下搜索并更新 $A[id]$ 的所有祖先。\n  取「节点 $u$ 代表区间」的中点：$m=(l(u)+r(u))÷2$；\n  若 $id≤m$，则 $A[id]$ 在左子树中，搜索左子节点：$set(2u,id,v)$；\n  若 $id\u0026gt;m$，则 $A[id]$ 在右子树中，搜索右子节点：$set(2u+1,id,v)$；\n  更新当前节点值：$t[u]=\\min(t[2u],t[2u+1])$。\n  主程序中执行 $set(1,id,v)$，时间复杂度为 $O(\\log{n})$。\nvoid set(int u, int id, int v) { // 将 a[id] 改为 v  if(l(u) == r(u)) { // 叶节点  a[id] = t(u) = v; return; } int m = (l(u) + r(u)) / 2; if(id \u0026lt;= m) set(2 * u, id, v); // a[id] 在左子树  else set(2 * u + 1, id, v); // a[id] 在右子树  t(u) = min(t(2 * u), t(2 * u + 1)); } 区间查询 $  线段树中，每个节点代表一个区间。那么反过来想，每个区间都可以用若干节点表示。例如 $A[1\\cdots 6]$ 的最小值 $=\\min(t[2],t[6])=2$。\n\r从根节点开始，自顶向下搜索出范围在 $[l,r]$ 之内的节点，这些节点的最小值即为答案。\n$get(u,l,r)$：从节点 $u$ 开始，向下搜索 $A[l\\cdots r]$ 的最小值。\n  若 $u$ 的范围在 $[l,r]$ 之内：直接返回 $t[u]$；\n  若 $u$ 的范围与 $[l,r]$ 没有重复部分：返回 $∞$1；\n  否则递归搜索 $u$ 的两个子节点：返回 $\\min(get(2u,l,r),get(2u+1,l,r))$。\n  时间复杂度为 $O(\\log{n})$，最终答案是 $get(1,l,r)$。\nint get(int u, int l, int r) { if(l \u0026lt;= l(u) \u0026amp;\u0026amp; r(u) \u0026lt;= r) return t(u); // 1. 被包含  else if(l(u) \u0026gt; r || r(u) \u0026lt; l) return 0x3f3f3f; // 2. 没有重复部分  int m = (l + r) / 2; return min(get(2 * u, l, m), get(2 * u + 1, m + 1, r)); // 3. 递归搜索 } 区间修改 + 延迟标记 $  如果一次性将 $A[3\\cdots 8]$ 每个数加上 $v$，需要更新大量节点，时间复杂度接近 $O(n\\log{n})$。这不是我们希望看到的。\n\r事实上，大部分节点用不着马上更新——直到它们再次被访问。于是我们可以先给部分节点打标记。\n在本例中，$t[3]$ 和 $t[5]$ 被打上了标记，这代表它们的所有子节点都还没加上 $v$。\n\r当访问 $A[5\\cdots 6]$ 时，再更新 $t[3]$ 的左子树 。$t[3]$ 的标记被下传到了它的右节点 $t[7]$。\n\r代码与 区间查询 类似。时间复杂度为 $O(\\log{n})$。\nint mark[]; void spread(int u) { // 更新 u 的子节点，并下传标记  if(mark[u]) { t(2 * u) += mark[u]; t(2 * u + 1) += mark[u]; mark[2 * u] += mark[u]; mark[2 * u + 1] += mark[u]; mark[u] = 0; } } void add(int u, int l, int r, int v) { // 将 A[l...r] 每个数加上 v  if(l \u0026lt;= l(u) \u0026amp;\u0026amp; r(u) \u0026lt;= r) { // 完全覆盖  t(u) += v, mark[u] += v; return; // 标记  } else if(l(u) \u0026gt; r || r(u) \u0026lt; l) return; spread(u); // 下传标记  int m = (l + r) / 2; add(2 * u, l, r, v); add(2 * u + 1, l, r, v); t(u) = min(t(2 * u), t(2 * u + 1)); } 同时， 单点修改 和 区间查询 需要添加下传标记的操作。\nvoid set(int u, int id, int v) { if(l(u) == r(u)) { a[id] = t(u) = v; return; } spread(u); // 下传标记  int m = (l(u) + r(u)) / 2; if(id \u0026lt;= m) set(2 * u, id, v); else set(2 * u + 1, id, v); t(u) = min(t(2 * u), t(2 * u + 1)); } int get(int u, int l, int r) { if(l \u0026lt;= l(u) \u0026amp;\u0026amp; r(u) \u0026lt;= r) return t(u); else if(l(u) \u0026gt; r || r(u) \u0026lt; l) return 0x3f3f3f; spread(u); // 下传标记  int m = (l + r) / 2; return min(get(2 * u, l, m), get(2 * u + 1, m + 1, r)); } 模板 $  struct Node { int val, l, r; #define t(u) t[u].val  #define l(u) t[u].l  #define r(u) t[u].r } t[]; int mark[]; void build(int u, int l, int r) { l(u) = l, r(u) = r; if(l == r) { // 当前节点为叶节点  t(u) = a[l]; return; } int m = (l + r) / 2; build(2 * u, l, m); // 递归构建左子树  build(2 * u + 1, m + 1, r); // 递归构建右子树  t(u) = min(t(2 * u), t(2 * u + 1)); } void spread(int u) { if(mark[u]) { t(2 * u) += mark[u]; t(2 * u + 1) += mark[u]; mark[2 * u] += mark[u]; mark[2 * u + 1] += mark[u]; mark[u] = 0; } } void set(int u, int id, int v) { if(l(u) == r(u)) { a[id] = t(u) = v; return; } spread(u); int m = (l(u) + r(u)) / 2; if(id \u0026lt;= m) set(2 * u, id, v); else set(2 * u + 1, id, v); t(u) = min(t(2 * u), t(2 * u + 1)); } int get(int u, int l, int r) { if(l \u0026lt;= l(u) \u0026amp;\u0026amp; r(u) \u0026lt;= r) return t(u); else if(l(u) \u0026gt; r || r(u) \u0026lt; l) return 0x3f3f3f; spread(u); int m = (l + r) / 2; return min(get(2 * u, l, m), get(2 * u + 1, m + 1, r)); } void add(int u, int l, int r, int v) { if(l \u0026lt;= l(u) \u0026amp;\u0026amp; r(u) \u0026lt;= r) { t(u) += v, mark[u] += v; return; } else if(l(u) \u0026gt; r || r(u) \u0026lt; l) return 0x3f3f3f; spread(u); int m = (l + r) / 2; add(2 * u, l, r, v); add(2 * u + 1, l, r, v); t(u) = min(t(2 * u), t(2 * u + 1)); } 变种线段树 $  线段树经过微调之后，还可以查询区间和。\n令每个节点代表一段区间的元素和，并且 $t[u]=t[2u]+t[2u+1]$。\n\r若 $t[u]$ 表示区间 $[l,r]$，而 $A[l\\cdots r]$ 每个数都要加上 $v$，则 $t[u]$ 需要加上 $(r-l+1)×v$。因此标记下传函数也需要调整。\nvoid spread(int u) { if(mark[u]) { t(2 * u) += mark[u] * (l(2 * u) - r(2 * u) + 1); t(2 * u + 1) += mark[u] * (l(2 * u + 1) - r(2 * u + 1) + 1); mark[2 * u] += mark[u]; mark[2 * u + 1] += mark[u]; mark[u] = 0; } }   $\\min(∞,a)=a$，因此返回 $∞$ 相当于不参与最小值的比较。 \u0026#x21a9;\u0026#xfe0e;\n   "}),a.add({id:41,href:'/docs/DS/ST/',title:"ST 表",section:"数据结构",content:"const int N = 1e6, logN = 32; int n, l, r, a[N], f[N][logN], Log[N]; void pre() { Log[0] = -1; for(int i = 1; i \u0026lt;= n; i ++) Log[i] = Log[i / 2] + 1; for(int j = 1; j \u0026lt; logN; j ++) for(int i = 1; i + (1 \u0026lt;\u0026lt; j - 1) \u0026lt;= n; i ++) f[i][j] = max(f[i][j - 1], f[i + (1 \u0026lt;\u0026lt; j - 1)][j - 1]); } int query(int l, int r) { // 返回 a[l...r] 中的最大值  int s = Log[r - l + 1]; return max(f[l][s], f[r - (1 \u0026lt;\u0026lt; s) + 1][s]); } int main() { cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i ++) cin \u0026gt;\u0026gt; a[i]; pre(); while(cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r) cout \u0026lt;\u0026lt; query(l, r) \u0026lt;\u0026lt; endl; } "}),a.add({id:42,href:'/docs/DP/zip/',title:"状压 DP",section:"动态规划",content:"简介 $  为了解决问题，有时需要在 $f[ \\ ]$ 数组的中括号里塞一些奇怪的东西。\n假设你要用 $\\spadesuit \\ \\heartsuit \\ \\clubsuit \\ \\diamondsuit$ 四种符号填满下面 $4×4$ 的表格，并且黑色符号只能和白色符号相邻。表格的第一行已经给出，问所有可行的方案中，第四行恰好也为 $\\spadesuit \\ \\heartsuit \\ \\clubsuit \\ \\diamondsuit$ 的有几种？\n   $\\spadesuit$ $\\heartsuit$ $\\clubsuit$ $\\diamondsuit$     $ \\ $ $ \\ $ $ \\ $ $ \\ $   $ \\ $ $ \\ $ $ \\ $ $ \\ $   $ \\ $ $ \\ $ $ \\ $ $ \\ $    设 $f[\\square\\square\\square\\square][i]$ 表示第 $i$ 行填 $\\square\\square\\square\\square$ 的可行方案数。我们要求解的是 $f[\\spadesuit \\ \\heartsuit \\ \\clubsuit \\ \\diamondsuit][4]$。由于黑色符号只能与白色符号相邻，因此：\n$$\r\\begin{aligned}\rf[\\spadesuit \\ \\heartsuit \\ \\clubsuit \\ \\diamondsuit][4]=\u0026f[\\heartsuit \\ \\spadesuit \\ \\diamondsuit \\ \\clubsuit][3]+f[\\diamondsuit \\ \\spadesuit \\ \\heartsuit \\ \\clubsuit][3]\\\\\r+\u0026f[\\heartsuit \\ \\clubsuit \\ \\diamondsuit \\ \\spadesuit][3]+f[\\diamondsuit \\ \\clubsuit \\ \\heartsuit \\ \\spadesuit][3]\r\\end{aligned}\r$$\n在程序中，我们一般通过 状态压缩 将一串符号转换为一个整数，这样 $f[ \\ ]$ 数组就变得可实现。\n具体怎么操作呢？使用数字 $1 \\ 2 \\ 3 \\ 4$ 分别替代字符 $\\spadesuit \\ \\heartsuit \\ \\clubsuit \\ \\diamondsuit$。上面的方程就会变为：\n$$\r\\begin{aligned}\rf[1234][4]=\u0026f[2143][3]+f[4123][3]\\\\\r+\u0026f[2341][3]+f[4321][3]\r\\end{aligned}\r$$\n状压 $DP$ 的核心就在于此。\n"}),a.add({id:43,href:'/docs/Tools/Dev-Cpp/',title:"Dev-C++",section:"工具",content:"Dev-C++ $  下载 Dev-C++ 5.11  Dev-C++ 5.10  Dev-C++ 5.09  Dev-C++ 5.08  Dev-C++ 5.07  Dev-C++ 5.06    "})})()