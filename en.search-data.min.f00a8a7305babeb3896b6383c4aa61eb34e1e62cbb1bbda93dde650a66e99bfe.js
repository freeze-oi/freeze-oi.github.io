'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/Basics/bfs/',title:"广度优先搜索",section:"基础算法",content:"简介 $  广度优先搜索（Breadth First Search，简称 BFS）按照层次顺序查找节点，如下图：\n\r  访问节点 0（根节点）；\n  访问节点 0 的所有子结点（结点 1、2）；\n  访问节点 1、2 的所有子结点（结点 3、4、5）；\n$\\cdots \\ \\cdots$\n  重复访问子结点的操作，直到访问到目标节点。\n基本原理 $    定义一个队列，用于存放节点编号；\n  将根节点编号插入队尾（入队）；\n  将队头的所有子节点入队，移除队头元素（出队），重复直到队列为空。\n  Warning\n为了避免重复访问同一节点，已经进过队列的结点不能再次入队。\n bool vis[]; // vis[i] 代表节点 i 是否进过队列  void bfs(int s, int e) { // 在根节点为 s 的图中找到节点 e memset(vis, false, sizeof vis); queue\u0026lt;int\u0026gt; Q; Q.push(s); // 根节点入队 while(!Q.empty()) { int top = Q.top(); Q.pop(); // 出队  if(top == e) return; // 找到结点 e  for(int i = top 的所有子节点编号) if(!vis[i]) // 如果没有进过队列  Q.push(i), vis[i] = true; // 入队  } } 节点层数 $  求任意节点所在的层数（深度）。\n 子节点层数 $=$ 父节点层数 $+$ $1$。  struct Node { int id, step; // id 为节点编号，step 为层数 }; bool vis[]; int bfs(int s, int e) { // 在根节点为 s 的图中，返回节点 e 的层数  memset(vis, false, sizeof vis); queue\u0026lt;Node\u0026gt; Q; Q.push(Node{s, 1}); while(!Q.empty()) { Node top = Q.top(); Q.pop(); if(top.id == e) return top.step; for(int i = top 的所有子节点编号) if(!vis[i]) { Q.push(Node{i, top.step + 1}); // 子节点层数 = 父节点层数 + 1  vis[i] = true; } } } "}),a.add({id:1,href:'/docs/DP/intro/',title:"简介",section:"动态规划",content:"简介 $  动态规划（DP） 是「打表」的最高境界，原理和考试时查草稿差不多。\n假如一道填空题需要求 $1024×768$，正常学生会在草稿纸上计算出它的值 $=768432$。\n\r此时某道应用题中再次出现了 $1024×768$：\n\r部分学生会在打过的草稿里找到 $1024×768=768432$，直接抄进答题卡，省得再计算。更专业的学生会把草稿打成表格，方便查表和检验。\n动态规划将「草稿纸」的参考性利用到极致，极大提高解题效率。\n基本原理 $  例题\n斐波那契数列是形如 $1, 1, 2, 3, 5, 8, \\cdots$ 的数列。求数列的第 $n$ 项。\n $f[n]$ 表示数列的第 $n$ 项，则：\n\r$$\rf[n]=\\left\\{\\begin{aligned}\r\u0026 1, n=1, 2\\\\\r\u0026 f[n-1]+f[n-2], n≥3\r\\end{aligned}\\right.\r$$\r\r先把特殊的 $f[1]=f[2]=1$ 填进表：\n   $f[1]$ $f[2]$     $1$ $1$    根据公式计算 $f[3]$ 时，需要用到 $f[1]$ 和 $f[2]$。在表中查找它们的值，代入计算：\n$$ f[3]=f[1]+f[2]=1+1=2 $$\n然后将 $f[3]$ 也填进表：\n   $f[1]$ $f[2]$ $\\color{red}{f[3]}$     $1$ $1$ $\\color{red}{2}$    重复查表 $-$ 计算 $-$ 填表步骤，直到算出 $f[n]$：\n   $f[1]$ $f[2]$ $f[3]$ $f[4]$ $f[5]$ $f[6]$ $f[7]$ $\\cdots$ $f[n]$     $1$ $1$ $2$ $3$ $5$ $8$ $11$ $\\cdots$     时间复杂度为 $O(n)$。\nint f[]; f[1] = f[2] = 1; for(int i = 3; i \u0026lt;= n; i ++) f[i] = f[i - 1] + f[i - 2]; 专业术语 $  问题和子问题 $  打个比方，求 $f[n]$ 是 （主）问题，则求 $f[n-1]$ 和 $f[n-2]$ 就是该问题的子问题。\n求主问题时，它的子问题必须先被填进表。例如求 $f[n]$ 时，$f[n-1]$ 和 $f[n-2]$ 必须先被填进表。\n状态转移方程 $  状态转移方程用于表示问题和子问题之间的关系：\n\r$$\rf[n]=\\left\\{\\begin{aligned}\r\u0026 1, n=1, 2\\\\\r\u0026 f[n-1]+f[n-2], n≥3\r\\end{aligned}\\right.\r$$\r\r初始、边界条件 $  初始条件：$f[1]=f[2]=1$。\n边界条件：$f[n]$ 被求出。\n动态规划从初始条件出发，一直填表计算到边界条件才结束。\n"}),a.add({id:2,href:'/docs/Basics/dfs/',title:"深度优先搜索",section:"基础算法",content:"简介 $  深度优先搜索（Depth First Search，简称 DFS）在查找节点时，尽可能往更深处搜索，如下图：\n\r基本原理 $  DFS 算法在本质上是一种递归：\n  若当前结点为目标结点，直接返回；\n  递归搜索当前结点的每个子节点。\n  void dfs(int s, int e) { // 从节点 i 出发，查找结点 e  if(s == e) return; // 找到结点 e  for(int i = 结点 k 的子节点编号) dfs(i, e); // 搜索  return; // 回溯（此处可以省略） } "}),a.add({id:3,href:'/docs/DP/memo/',title:"记忆化搜索",section:"动态规划",content:"普通搜索 $  求 斐波那契数列 第 $i$ 项（$f[i]$）的深搜程序如下：\nint f(int x) { if(x \u0026lt;= 2) return 1; return f(x - 1) + f(x - 2); } 执行 $f(7)$ 的调用情况如下：\n\r随着 $n$ 的增大，$f(n)$ 的时间复杂度呈指数级增长。如果遇到大数据，你的程序就会：\n\r记忆化搜索 $  考虑开数组 $F[ \\ ]$ 保存计算结果，从而避免重复计算。\n  若 $f(x)$ 未被调用，算出 $f(x)$ 的结果，并存入 $F[\\text{x}]$；\n  若 $f(x)$ 已经被调用过，直接返回 $F[\\text{x}]$。\n  和 动态规划 中的填表思想如出一辙。\nint F[] = {0, 1, 1}; int f(int x) { if(F[x] != 0) return f[x]; // 如果 F[x] ≠ 0，则 f(x) 已经被调用过  return F[x] = f(x - 1) + f(x - 2); // 返回时保存 } 执行 $f(7)$ 的调用情况如下：\n\r记忆化搜索的效率和动态规划相当，设计难度低于动态规划。若难以判断计算顺序，则可以采用该算法。\n"}),a.add({id:4,href:'/docs/DP/basics/',title:"基础 DP",section:"动态规划",content:"斐波那契数列 $  斐波那契数列是形如 $1,1,2,3,5,8,\\cdots$ 的数列。求数列的第 $n$ 项。\n$f[n]$ 表示数列的第 $n$ 项，则：\n$$ f[n]=f[n-1]+f[n-2],n≥3 $$\n   初始条件 $f[1]=f[2]=1$ 计算顺序 $f[3\\rightarrow n]$     边界条件 $f[n]$ 时间复杂度 $O(n)$    int f[]; f[1] = f[2] = 1; for(int i = 3; i \u0026lt;= n; i ++) f[i] = f[i - 1] + f[i - 2]; 汉诺塔问题 $  汉诺塔由 $n$ 个大小不同的圆盘和三根杆子 $a,b,c$ 组成。初始时，$n$个圆盘从大到小依次套在 $a$ 杆上，如下图所示：\n\r现在要求把 $a$ 杆上的 $n$ 个圆盘按以下规则移到 $c$ 杆上：\n  一次只能移动一个圆盘；\n  圆盘只能存放在柱子上；\n  在移动的过程中，大圆盘不能压在小圆盘上。\n  求圆盘的最少移动次数。\n$f[n]$ 表示将 $n$ 个圆盘从一个杆整体移到另一个杆，需要的最少移动次数。\n将 $n$ 个盘子从小到大编号为 $1\\sim n$。将它们从 $a$ 杆移到 $c$ 杆，需要做以下 $3$ 步：\n  将 $a$ 杆上的 $1\\sim n-1$ 号盘移至 $b$ 杆，总移动次数为 $f[n-1]$；\n  将 $a$ 杆上的 $n$ 号盘移至 $c$ 杆，总移动次数为 $1$；\n  将 $b$ 杆上的 $1\\sim n-1$ 号盘移至 $c$ 杆，总移动次数为 $f[n-1]$。\n  $$ f[n]=2·f[n-1]+1,n≥1 $$\n   初始条件 $f[1]=1$ 计算顺序 $f[2\\rightarrow n]$     边界条件 $f[n]$ 时间复杂度 $O(n)$    int f[]; f[1] = 1; for(int i = 2; i \u0026lt;= n; i ++) f[i] = 2 * f[i - 1] + 1; 骨牌问题 $  用若干个 $1×2$ 的骨牌铺满 $2×n$ 的方格。如图为 $n=3$ 时的所有铺法：\n\r求任意的 $n$ 对应的铺法总数。\n$f[n]$ 表示 $2×n$ 方格的铺法总数。对于不好分析的问题，先用枚举法找出规律：\n  若 $n=1$，显然只有一种铺法，$f[1]=1$；\n  若 $n=2$，可以全部竖放，或全部横放，$f[2]=2$\n  若 $n=3$，可以全部竖放，或一个竖放，两个横放，共 $3$ 种放法。$f[3]=3$。\n  \r总结出一般规律：\n  若第一个骨牌竖放在左边，则剩下 $2×(n-1)$ 个方格未铺满，铺法数为 $f[n-1]$；\n  若第一个骨牌横放在左上角，为了不留空，第二个骨牌必须横放在它的正下方。剩下 $2×(n-2)$ 个方格未铺满，铺法数为 $f[n-2]$。\n  $$ f[n]=f[n-1]+f[n-2],n≥3 $$\n状态转移方程恰好和 斐波那契数列相同。\nInfo\n不同问题的状态转移方程可能相同。\n 平面分割 $  平面上有 $n$ 条封闭曲线，每 $2$ 条封闭曲线恰好相交于 $2$ 点，且每 $3$ 条封闭曲线不交于同一点。求 $n$ 条封闭曲线把平面分割成的区域个数。\n\r$a[n]$ 表示 $n$ 条封闭曲线分割成的区域个数，由上图可得：$a[2]-a[1]=2$，$a[3]-a[2]=4$，$a[4]-a[3]=6$，总结出规律: $a[n]-a[n-1]=2(n-1)$。变形得：\n$$ a[n]=a[n-1]+2(n-1),n≥1 $$\n正确性证明：\n新增一条曲线时：\n$∵$ 每与平面上一条已有曲线相交一次，就会增加一个区域，\n$∴$ 新增区域数 $=$ 新增交点数。\n$∵$ 新增的第 $n$ 条曲线与已有的 $n-1$ 条曲线各有 $2$ 个交点，\n$∴$ 新增区域数 $=$ 新增交点数 $=2·(n-1)$。\n$∴$ 现有区域个数 $a[n]=$ 原有区域个数 $+$ 新增区域个数 $=a[n-1]+2(n-1)$。\n   初始条件 $a[1]=2$ 计算顺序 $a[2\\rightarrow n]$     边界条件 $a[n]$ 时间复杂度 $O(n)$    int a[]; a[1] = 2; for(int i = 2; i \u0026lt;= n; i ++) a[i] = a[i - 1] + 2 * (n - 1); 最长上升子序列（LIS） $  Info\n$A$ 的任意子序列 $B$ 可以表示为 $B={A_{k_1} \\ ,A_{k_2} \\ ,\\cdots,A_{k_p} \\ }$ ，其中 $k_1\u0026lt;k_2\u0026lt;\\cdots\u0026lt;k_p$ 。\n若 $A$ 的子序列 $B$ 满足 $A_{k_1}\u0026lt;A_{k_2}\u0026lt;\\cdots\u0026lt;A_{k_p}$ ，则 $B$ 是 $A$ 的上升子序列。\n 数列 $A$ 的长度为 $n$，求 $A$ 的最长上升子序列的长度。\n样例：$A={2,3,6,4,5,1}$，最长上升子序列 $={2,3,4,5}$，长度为 $4$。\n$f[i]$ 表示以 $A_i$ 结尾的最长上升子序列的长度。求 $f[i]$ 时，子问题 $f[1\\sim i-1]$ 已求得最优解，故枚举 $j=1\\cdots i-1$ 并做以下判断：\n  若 $A_j\u0026lt;A_i$，则 $A_i$ 可以接在 $A_j$ 之后，最长上升子序列长度为 $f[j]+1$；\n  若 $A_j≥A_i$，则 $A_i$ 不可以接在 $A_j$ 之后，跳过。\n  $$ f[i]=\\max_{j\u0026lt;i, \\ A_j\u0026lt;A_i}(f[j])+1 $$\n   初始条件 $f[1\\cdots n]=1$ 计算顺序 $f[1\\rightarrow n]$     边界条件 $f[1\\cdots n]$ 的最大值 时间复杂度 $O(n^2)$    for(int i = 1; i \u0026lt;= n; i ++) { f[i] = 1; for(int j = 1; j \u0026lt; i; j ++) if(a[j] \u0026lt; a[i]) f[i] = max(f[i], f[j] + 1); } 单调栈优化 $  运用 单调栈优化时间复杂度。依次扫描数组元素：\n  若当前元素大于栈顶元素，则将其插入单调栈；\n  否则二分查找栈中第一个比当前元素大的元素，并替换。\n  由于 STL Stack 不支持访问栈内元素，故使用 STL Vector 模拟栈。最终的答案是栈的长度。时间复杂度为 $O(n\\log{n})$。\nvector\u0026lt;int\u0026gt; s = (1, a[1]); for(int i = 2; i \u0026lt;= n; i ++) { if(a[i] \u0026gt; s.back()) s.push_back(a[i]); else s[*lower_bound(s.begin(), s.end(), a[i])] = a[i]; } 最长公共子序列（LCS） $  Info\n若一个序列既是 $A$ 的子序列，又是 $B$ 的子序列，则它是 $A$ 和 $B$ 的公共子序列。\n 给定长度分别为 $n$ 和 $m$ 的两个字符串 $A$、$B$，求 $A$ 和 $B$ 的最长公共子序列[^LCS]长度。\n样例：$A=$ freeze，$B=$ refeze，最长公共子序列 $=$ reeze，长度为 $5$。\n$f[i,j]$ 表示 $A[1\\cdots i]$ 和 $B[1\\cdots j]$ 的最长公共子序列长度。\n  若 $A_i≠B_j$，则继承最优子状态。子问题 $f[i-1,j]$ 和 $f[i,j-1]$ 已求得最优解，故令 $f[i,j]=\\max(f[i-1,j],f[i,j-1])$；\n  若 $A_i=B_j$，则 $A_i$（或 $B_j$）可以接在 $A[1\\cdots i-1]$ 和 $B[1\\cdots j-1]$ 的最长公共子序列之后，生成的新序列长度为 $f[i-1,j-1]+1$。\n  \r$$\rf[i,j]=\\max\\left\\{\\begin{aligned}\r\u0026f[i-1,j]\\\\\r\u0026f[i,j-1]\\\\\r\u0026f[i-1,j-1]+1,A_i=B_j\r\\end{aligned}\\right.\r$$\r\r   初始条件 无 计算顺序 $f[i=1\\rightarrow n,j=1\\rightarrow m]$     边界条件 $f[n,m]$ 时间复杂度 $O(nm)$    for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } 数字金字塔 $  三角矩阵 $A$ 有 $n$ 行，第 $i$ 行有 $i$ 列。从第一行第一列出发，每次可以移动到下一行相邻的两个数字。到达底部时，经过的数字之和最大为多少？\n样例：\n\n最优路径为 $13→8→26→15$，最大值为 $62$。\n$(i,j)$ 表示矩阵第 $i$ 行第 $j$ 列的数字。$f[i,j]$ 表示走到 $(i,j)$ 时，经过的数字之和的最大值。\n采用逆推法：要想走到 $(i,j)$，上一步只能在 $(i-1,j-1)$ 或 $(i-1,j)$：\n  若上一步在 $(i-1,j-1)$，则 $f[i,j]=(i,j)+f[i-1,j-1]$；\n  若上一步 $(i-1,j)$，则 $f[i,j]=(i,j)+f[i-1,j]$。\n  \r$$\rf[i,j]=(i,j)+\\max\\left\\{\\begin{aligned}\r\u0026f[i-1,j-1]\\\\\r\u0026f[i-1,j]\r\\end{aligned}\\right.\r$$\r\r   初始条件 $f[1,1]=(1,1)$ 计算顺序 $f[i=2\\rightarrow n,j=1\\rightarrow i]$     边界条件 $f[n,1\\cdots n]$ 的最大值 时间复杂度 $O(n^2)$    Warning\n当 $j=1$ 或 $j=i$ 时，$f[i-1,j-1]$ 和 $f[i-1,j]$ 会越界。读入数据前要将 $f$ 数组初始化为 $-∞$，从而使越界的元素在取最大值时被自动淘汰。\n memset(f, 0x80, sizeof f); f[1][1] = 1; for(int i = 2; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= i; j ++) { cin \u0026gt;\u0026gt; cnt; f[i][j] = cnt + max(f[i - 1][j - 1], f[i - 1][j]); } for(int i = 1; i \u0026lt;= n; i ++) ans = max(ans, f[n][i]); 数字矩阵 $  数字矩阵 $A$ 有 $n$ 行 $m$ 列。从左上角的元素出发，每次只能向下或向左走。到达右下角时，经过的数字之和最大为多少？\n样例：\n\n最优路径为 $17→1→20→12→9→2$，最大值为 $61$。\n$(i,j)$ 表示矩阵第 $i$ 行第 $j$ 列的数字。$f[i,j]$ 表示走到 $(i,j)$ 时，经过的数字之和的最大值。\n由于只能向左走或向下走，要走到 $(i,j)$，上一步只能在 $(i-1,j)$ 或 $(i,j-1)$：\n\r$$\rf[i,j]=(i,j)+\\max\\left\\{\\begin{aligned}\r\u0026f[i-1,j]\\\\\r\u0026f[i,j-1]\r\\end{aligned}\\right.\r$$\r\r   初始条件 $f[1,1]=(1,1)$ 计算顺序 $f[i=1\\rightarrow n,j=1\\rightarrow m]$     边界条件 $f[n,m]$ 时间复杂度 $O(nm)$    Warning\n当 $i=1$ 或 $j=1$ 时，$f[i-1,j]$ 和 $f[i,j-1]$ 会越界。同样需要将 $f$ 数组初始化为 $-∞$。\n memset(f, 0x80, sizeof f); for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= m; j ++) { cin \u0026gt;\u0026gt; cnt; if(i == 1 \u0026amp;\u0026amp; j == 1) f[i][j] = cnt; else f[i][j] = cnt + max(f[i-1][j], f[i][j - 1]); } 前缀和 $  前缀和是一种重要的预处理技巧，能大幅降低「查询区间元素和」的时间复杂度。\n一维前缀和 $  数列 $A$ 有 $n$ 个元素，$f[i]$ 表示 $A_1+A_2+\\cdots+A_i$，则有：\n$$ f[i]=f[i-1]+A_i $$\n   初始条件 $f[0]=0$ 计算顺序 $f[1]\\rightarrow f[n]$     时间复杂度 $O(n)$      前缀和可以实现快速查询数列的子段和。$g[i,j]$ 表示从 $A_i$ 到 $A_j$ 的所有元素和，则有：\n\r$$ g[i,j]=f[j]-f[i-1] $$\n单次查询的时间复杂度为 $O(1)$。\nint g(int i, int j) { return f[j] - f[i - 1]; } int main() { for(int i = 1; i \u0026lt;= n; i ++) f[i] = f[i - 1] + a[i]; while(cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r) cout \u0026lt;\u0026lt; g(l, r) \u0026lt;\u0026lt; endl; } 二维前缀和 $  矩阵 $A$ 有 $n$ 行 $m$ 列。$f[i,j]$ 表示以 $(1,1)$ 为左上角，以 $(i,j)$ 为右下角的子矩阵的元素和，则：\n\r$$ f[i,j]=f[i-1,j]+f[i,j-1]-f[i-1,j-1]+(i,j) $$\n   初始条件 $f[0,0]=0$ 计算顺序 $f[1\\rightarrow n,1\\rightarrow m]$     时间复杂度 $O(nm)$      二维前缀和可以实现快速查询子矩阵元素和。$g[x_1,y_1,x_2,y_2]$ 表示以 $(x_1,y_1)$ 为左上角，$(x_2,y_2)$ 为右下角的子矩阵元素和，则：\n\r$$ g[x_1,y_1,x_2,y_2]=f[x_2,y_2]-f[x_1-1,y_2]-f[x_2,y_1-1]+f[x_1-1,y_1-1] $$\n单次查询的时间复杂度为 $O(1)$。\nint g(int x1, int y1, int x2, int y2) { return f[x2][y2] - f[x1 - 1][y2] - f[x2][y1 - 1] + f[x1 - 1][y1 - 1]; } int main() { f[0][0] = 0; for(int i = 1; i \u0026lt;= n; i ++) for(int j = 1; j \u0026lt;= m; j ++) f[i][j] = f[i - 1][j] + f[i][j - 1] + a[i][j]; while(cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2) cout \u0026lt;\u0026lt; g(x1, y1, x2, y2) \u0026lt;\u0026lt; endl; } 差分 $  差分是 前缀和 的逆运算，能大幅降低「区间批量操作」的时间复杂度。\n数列 $A$ 有 $n$ 个元素。$f[i]$ 代表数列 $A$ 第 $i$ 项和前一项的差，即：\n$$ f[i]=A_i-A_{i-1} $$\n   初始条件 $f[1]=A_1$ 计算顺序 $f[1\\rightarrow n]$     时间复杂度 $O(n)$      $f$ 被称作「差分数列」。数列 $A={5,2,3,1,6,4}$ 的差分数列为 $f={5,-3,1,-2,5,-2}$。\n将 $A[l\\cdots r]$ 中的每个元素都加上 $x$ 时，差分数列中 $f[l]$ 增加了 $x$，$f[r+1]$ 减少了 $x$，其余元素不变。因此每次只修改 $f[l]$ 和 $f[r+1]$ 的值，最后通过 $f$ 数列还原 $A$ 中的元素，即：\n$$ A_i=A_{i-1}+f[i] $$\n单次批量操作的时间复杂度为 $O(1)$。\nvoid add(int l, int r, int x) {// 将区间 [l, r] 批量加 x  f[l] += x, f[r + 1] -= x; } void query() { // 还原数组元素  for(int i = 1; i \u0026lt;= n; i ++) a[i] = a[i - 1] + f[i]; } int main() { for(int i = 1; i \u0026lt;= n; i ++) f[i] = a[i] - a[i - 1]; int l, r, x; while(cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x) { add(l, r, x); } query(); } "}),a.add({id:5,href:'/docs/Basics/sort/',title:"排序算法",section:"基础算法",content:"选择排序 $  每次找出第 $i$ 小的元素，与数组第 $i$ 个位置上的元素交换。时间复杂度为 $O(n^2)$。\nfor(int i = 1; i \u0026lt;= n; i ++) for(int j = i + 1; j \u0026lt;= n; j ++) if(a[j] \u0026lt; a[k]) swap(a[i],a[k]); 冒泡排序 $  每次检查相邻两个元素，如果前一个大于后一个，就交换它们的位置。当没有可交换的元素时，排序结束。时间复杂度为 $O(n^2)$。\n在程序的执行过程中，较大的元素像气泡般「浮」到数列的末尾，故叫做冒泡排序。\nwhile(true) { bool solve = false; for(int i = 1; i \u0026lt;= n; i ++) if(a[i] \u0026gt; a[i + 1]) swap(a[i], a[i + 1]), solve = true; if(!solve) break; } 插入排序 $  将数列分为「已排序」和「未排序」两部分，每次从「未排序」区域中选择一个元素插入「已排序」区域的正确位置。时间复杂度为 $O(n^2)$。\nfor(int i = 2; i \u0026lt;= n; i ++) { int cnt = a[i], j = i - 1; while(j \u0026gt;= 1 \u0026amp;\u0026amp; a[j] \u0026gt; cnt) a[j + 1] = a[j --]; a[j + 1] = cnt; } 计数排序 $  $f[i]$ 表示元素 $i$ 的出现次数。\n  扫描数组，将当前元素 $v$ 对应的 $f[v]$ 加一；\n  遍历 $f[i=1\\cdots maxn]$，依次输出 $f[i]$ 个 $i$。\n  时间复杂度为 $O(n)$。\nWarning\n当元素范围过大时，不宜使用计数排序。\n int maxn = -1e9, p = 1; for(int i = 1; i \u0026lt;= n; i ++) { f[a[i]] ++; maxn = max(maxn, a[i]); } for(int i = 1; i \u0026lt;= maxn; i ++) for(int i = 1; i \u0026lt;= f[i]; i ++) a[++ p] = i; 快速排序 $    设定基准数（通常是数列最中间的数），将小于基准数的数放在它左边，大于它的放在右边；\n  递归排序基准数的左右两部分。\n  平均时间复杂度为 $o(n\\log{n})$，最坏时间复杂度为 $O(n^2)$。\nvoid qsort(int l, int r) { if(l \u0026gt;= r) return; int i = l, j = r, m = (l + r) / 2; while(i \u0026lt;= j) { while(a[i] \u0026lt; a[m]) i ++; while(a[j] \u0026gt; a[m]) j --; if(i \u0026lt;= j) swap(a[i ++], a[j --]); } qsort(l, j), qsort(i, r); } 归并排序 $    将数列分为左右两个子序列；\n  递归排序左右子序列；\n  合并两个子序列。\n  时间复杂度为 $O(n\\log{n})$。\nvoid msort(int l, int r) { if(l == r) return; int m = (l + r) / 2; msort(l, m), msort(m + 1, r); int i = l, j = m + 1, k = l; while(i \u0026lt;= m \u0026amp;\u0026amp; j \u0026lt;= r) if(a[i] \u0026lt;= a[j]) b[k ++] = a[i ++]; else b[k ++] = a[j ++]; while(i \u0026lt;= m) b[k ++] = a[i ++]; while(j \u0026lt;= n) b[k ++] = a[j ++]; for(int i = l; i \u0026lt;= r; i ++) a[i] = b[i]; } 猴子排序 $  从数列中随机选取两个元素交换位置，重复直到所有元素升序排列。平均时间复杂度为 $O(n·n!)$，最优时间复杂度为 $O(n)$，最坏时间复杂度为 $O(∞)$。\nsrand(unsigned(time(0))); // 伪随机种子 while(true) { swap(a[rand() % n + 1], a[rand() % n + 1]); bool solve = true; for(int i = 2; i \u0026lt;= n; i ++) if(a[i] \u0026lt; a[i - 1]) solve = false; if(solve) break; } 各类排序算法的比较 $     排序算法 平均 最好 最坏 稳定性     选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ 不稳定   冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ 稳定   插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ 稳定   计数排序 $O(n)$ $O(n)$ $O(n)$ 稳定   快速排序 $O(n\\log{n})$ $O(n\\log{n})$ $O(n^2)$ 不稳定   归并排序 $O(n\\log{n})$ $O(n\\log{n})$ $O(n\\log{n})$ 稳定   猴子排序 $O(n·n!)$ $O(n)$ $O(∞)$ 不稳定    求逆序对 $  Warning\n该模块正在开发中。\n "}),a.add({id:6,href:'/docs/Basics/binary/',title:"二分算法",section:"基础算法",content:"简介 $  玩过「数字炸弹」游戏吗？\n  叫你的朋友在你背后写一个 $[1,1000]$ 中的正整数 $n$；\n  每轮你都会给出数字 $x$，你朋友只能回答「$n$ 比 $x$ 大」「$n$ 比 $x$ 小」或「猜中」。\n  一旦猜中，数字炸弹就会爆炸。你能求出引爆炸弹的最少次数吗？\n最初 $n∈(0,1001)$。你可以先猜 $500$：\n  若 $n\u0026gt;500$，则可以进一步确定 $n∈(500,1001)$；\n  若 $n\u0026lt;500$，则可以进一步确定 $n∈(0,500)$；\n  否则 $n=500$，猜中。\n  重复猜范围的中间数，每次都会将 $n$ 的范围缩小一半，最多 $\\log{n}$ 次就可以确定 $n$ 的值。\n通过若干次折半范围实现快速查询，是二分算法的基本思想。\n基本原理 $  $l$ 表示 $n$ 所在范围的左端点，$r$ 表示右端点，即 $n∈(l,r)$。重复执行以下操作：\n  取范围的中间数 $m=\\lfloor(l+r)/2\\rfloor$；\n  若 $n\u0026gt;m$，则可以确定 $n∈(m,r)$，令 $l=m$；\n  若 $n\u0026lt;m$，则可以确定 $n∈(l,m)$，令 $r=m$；\n  若 $n=m$，跳出循环。\n  初始条件：$l=0,r=1001$。时间复杂度为 $O(\\log{n})$。\nint binSearch(int n) { // 使用二分算法猜出 n 的最少次数  int l = 0, r = 1001, frq = 0; // frq 记录次数  while(++ frq) { int m = (l + r) / 2; if(n \u0026gt; m) l = m; else if(n \u0026lt; m) r = m; else break; } return frq; } "}),a.add({id:7,href:'/docs/DP/knap/',title:"背包 DP",section:"动态规划",content:"01 背包 $  用体积为 $m$ 的背包装 $n$ 种物品，每种物品只有 $1$ 个。第 $i$ 种物品的体积为 $w_i$，价值为 $c_i$，将哪些物品装入背包可使总价值最大？\n$f[i,v]$ 表示把前 $i$ 个物品（部分或全部）放入体积为 $v$ 的背包，可以获得的最大总价值。\n若只考虑第 $i$ 个物品的策略（放或不放），则问题转而只涉及到前 $i-1$ 个物品：\n  若不放第 $i$ 个物品，则 $f[i,v]=f[i-1,v]$；\n  若放第 $i$ 个物品，则前 $i-1$ 个物品只能放在体积为 $v-w_i$ 的空间里，故 $f[i,v]=f[i-1,v-w_i]+c_i$。\n  \r$$\rf[i,v] = \\max\\left\\{\\begin{aligned}\r\u0026f[i-1,v]\\\\\r\u0026f[i-1,v-w_i]+c_i,v≥w_i\r\\end{aligned}\\right.\r$$\r\r由于 $f[i,v]$ 的值只由 $f[i-1,v]$ 和 $f[i-1,v-w_i]$ 决定，所以先求 $f[1,0\\cdots m]$，再求 $f[2,0\\cdots m]$，$\\cdots$，直到求出 $f[n,m]$。时间复杂度为 $O(nm)$。\nWarning\n当 $v \u0026lt; w_i$ 时，第 $i$ 个物品放不进体积为 $v$ 的背包，此时 $f[i,v]$ 只能等于 $f[i-1,v]$。\n for(int i = 1; i \u0026lt;= n; i ++) { for(int v = 0; v \u0026lt; w[i]; v ++) f[i][v] = f[i - 1][v]; for(int v = w[i]; v \u0026lt;= m; v ++) f[i][v] = max(f[i - 1][v], f[i - 1][v - w[i]] + c[i]); } 空间优化 $  假设背包体积为 $4$，物品个数为 $3$，体积和价值如下：\n   序号 体积 $w$ 价值 $c$     $1$ $1$ $2$   $2$ $2$ $3$   $3$ $1$ $3$    第 $i$ 行第 $v$ 列的格子 $(i,v)$ 存放 $f[i,v]$ 的值。运行 01 背包程序可以得到下表：\n   $i\\setminus v$ $0$ $1$ $2$ $3$ $4$     $0$ $0$ $0$ $0$ $0$ $0$   $1$ $0$ $2$ $2$ $2$ $2$   $2$ $0$ $2$ $3$ $5$ $5$   $3$ $0$ $3$ $5$ $6$ $8$    由于每一行的数据只与上一行有关，事实上可以去掉 $1$ 维：\n\r$$\rf[\\color{lightgray}i,\\color{black}v] = \\max\\left\\{\\begin{aligned}\r\u0026f[\\color{lightgray}i-1,\\color{black}v]\\\\\r\u0026f[\\color{lightgray}i-1,\\color{black}v-w_i]+c_i,v≥w_i\r\\end{aligned}\\right.\r$$\r\r需要保证更新 $f[v]$ 时，$f[v-w_i]$ 在第 $i$ 行还没被更新，因此降序枚举 $v$。\n用 $1$ 号物品（$w_1=1,c_1=2$）更新 $f[4\\cdots 0]$：\n   $f\\setminus v$ $0$ $1$ $2$ $3$ $4$     $f$（上一行） $0$ $0$ $0$ $0$ $0$   更新 $f[4]$ $0$ $0$ $0$ $\\color{blue}{0}$ $\\color{blue}{f[4-1]}\\color{red}{+2}$   更新 $f[3]$ $0$ $0$ $\\color{blue}{0}$ $\\color{blue}{f[3-1]}\\color{red}{+2}$ $2$   更新 $f[2]$ $0$ $\\color{blue}{0}$ $\\color{blue}{f[2-1]}\\color{red}{+2}$ $2$ $2$   更新 $f[1]$ $\\color{blue}{0}$ $\\color{blue}{f[1-1]}\\color{red}{+2}$ $2$ $2$ $2$   更新 $f[0]$ $\\color{blue}{f[0]=0}$ $2$ $2$ $2$ $2$   $f$ $0$ $2$ $2$ $2$ $2$    for(int i = 1; i \u0026lt;= n; i ++) for(int v = m; v \u0026gt;= w[i]; v --) f[v] = max(f[v], f[v - w[i]] + c[i]); 完全背包 $  如果每种物品都有无限个？\n$f[i,v]$ 表示把前 $i$ 种物品放入体积为 $v$ 的背包，可以获得的最大总价值。\n  若不放第 $i$ 种物品，则 $f[i,v]=f[i-1,v]$；\n  若多放入 $1$ 个第 $i$ 种物品，则剩余的前 $i$ 种物品只能放在体积为 $v-w_i$ 的空间里，故 $f[i,v]=f[i,v-w_i]+c_i$。\n  \r$$\rf[i,v] = \\max\\left\\{\\begin{aligned}\r\u0026f[i-1,v]\\\\\r\u0026f[i,v-w_i]+c_i,v≥w_i\r\\end{aligned}\\right.\r$$\r\r时间复杂度为 $O(nm)$。\nfor(int i = 1; i \u0026lt;= n; i ++) { for(int v = 0; v \u0026lt; w[i]; v ++) f[i][v] = f[i - 1][v]; for(int v = w[i]; v \u0026lt;= m; v ++) f[i][v] = max(f[i - 1][v], f[i][v - w[i]] + c[i]); } 空间优化 $  完全背包同样也可以省去一维：\n\r$$\rf[\\color{lightgray}i,\\color{black}v] = \\max\\left\\{\\begin{aligned}\r\u0026f[\\color{lightgray}i-1,\\color{black}v]\\\\\r\u0026f[\\color{lightgray}i,\\color{black}v-w_i]+c_i,v≥w_i\r\\end{aligned}\\right.\r$$\r\r需要保证更新 $f[v]$ 时，$f[v-w_i]$ 在第 $i$ 行已经被更新了，因此升序枚举 $v$。\n沿用 01 背包的例子，改变 $v$ 的枚举顺序为升序：\n用 $1$ 号物品（$w_1=1,c_1=2$）更新 $f[0\\cdots 4]$：\n   $f\\setminus v$ $0$ $1$ $2$ $3$ $4$     $f$（上一行） $0$ $0$ $0$ $0$ $0$   更新 $f[0]$ $\\color{blue}{f[0]=0}$ $0$ $0$ $0$ $0$   更新 $f[1]$ $\\color{blue}{0}$ $\\color{blue}{f[1-1]}\\color{red}{+2}$ $0$ $0$ $0$   更新 $f[2]$ $0$ $\\color{blue}{2}$ $\\color{blue}{f[2-1]}\\color{red}{+2}$ $0$ $0$   更新 $f[3]$ $0$ $2$ $\\color{blue}{4}$ $\\color{blue}{f[3-1]}\\color{red}{+2}$ $0$   更新 $f[4]$ $0$ $2$ $4$ $\\color{blue}{6}$ $\\color{blue}{f[4-1]}\\color{red}{+2}$   $f$ $0$ $2$ $4$ $6$ $8$    for(int i = 1; i \u0026lt;= n; i ++) for(int v = w[i]; v \u0026lt;= m; v ++) f[v] = max(f[v], f[v - w[i]] + c[i]); 多重背包 $  如果 $n$ 种物品分别有 $s_1,s_2,\\cdots,s_n$ 个？\n第 $i$ 个物品有 $s_i+1$ 种策略（取 $0\\sim s_i$ 件）。在 01 背包的基础上，再枚举物品个数 $k$，每次绑定 $k$ 个物品当成一个物品。\n\r$$\rf[v] = \\max\\left\\{\\begin{aligned}\r\u0026f[v]\\\\\r\u0026f[v-k·w_i]+k·c_i,v≥k·w_i\r\\end{aligned}\\right.\r$$\r\r时间复杂度为 $O(m\\sum s_i)$。\nfor(int i = 1; i \u0026lt;= n; i ++) for(int v = m; v \u0026gt;= w[i]; v --) for(int k = 0; k \u0026lt;= s[i] \u0026amp;\u0026amp; v \u0026gt;= k * w[i]; k ++) f[v] = max(f[v], f[v - k * w[i]] + k * c[i]); 转换为 01 背包 $    在 $1,2,4,\\cdots,2^n$ 中选出若干个相加，可以得到 $0\\sim 2^{n+1}-1$ 中的任意整数。\n  同理，$1,2,4,\\cdots,2^k,n-(2^{k+1}-1)$ 可以组合出 $0\\sim n$ 中的任意整数，其中 $k$ 是满足 $n-(2^{k+1}-1)\u0026gt;0$ 的最大整数。\n  将第 $i$ 种物品拆分成 $\\log{s_i}$ 个物品，它们的体积和价值如下：\n   体积 $w$ $w_i$ $2w_i$ $4w_i$ $\\cdots$ $2^kw_i$ $[s_i-(2^{k+1}-1)]w_i$     价值 $v$ $c_i$ $2c_i$ $4c_i$ $\\cdots$ $2^kc_i$ $[s_i-(2^{k+1}-1)]c_i$    这些物品可以组合出第 $i$ 个物品的所有选择方案（取 $0\\sim s_i$ 件）。用 01 背包的策略处理出最佳选择方案。时间复杂度为 $O(m\\sum\\log{s_i})$\nInfo\n完全背包也可以用相同的方法进行优化。\n for(int i = 1; i \u0026lt;= n; i ++) { int wi, ci, si, k = 1; cin \u0026gt;\u0026gt; wi \u0026gt;\u0026gt; ci \u0026gt;\u0026gt; si; while(k \u0026lt;= si) { w[++ tot] = wi * k, c[tot] = ci * k; si -= k, k *= 2; } w[++ tot] = wi * si, c[tot] = ci * si; } for(int i = 1; i \u0026lt;= tot; i ++) for(int v = m; v \u0026gt;= w[i]; v --) f[v] = max(f[v], f[v - w[i]] + c[i]); 分组背包 $  给定 $t$ 组物品，第 $k$ 组有 $s_k$ 个物品，第 $k$ 组第 $i$ 个物品体积为 $w_{k \\ i}$，价值为 $c_{k \\ i}$。每组中的物品互相冲突，最多选一件。将哪些物品放入背包可使总价值最大？\n$f[k,v]$ 表示将前 $k$ 组的物品放入体积为 $v$ 的背包中，可以获得的最大总价值。\n第 $k$ 组的选择策略如下：\n\r$$\rf[k,v] = \\max\\left\\{\\begin{aligned}\r\u0026f[k-1,v]\\\\\r\u0026\\max_{1≤i≤s_k} \\ f[k-1,v-w_{k \\ i}]+c_{k \\ i},v≥w_{k \\ i}\r\\end{aligned}\\right.\r$$\r\r和 01 背包类似，同样可以省去一维。时间复杂度为 $O(nm)$。\n枚举第 $k$ 组物品的循环应放在最内层。若放在外层，则等价于 01 背包，失去了分组的意义。\nfor(int k = 1; k \u0026lt;= t; k ++) for(int v = m; v \u0026gt;= 0; v --) for(int i = 1; i \u0026lt;= s[k]; i ++) if(v \u0026gt;= w[k][i]) f[v] = max(f[v],f[v - w[k][i]] + c[k][i]); 二维背包 $  背包的体积为 $m_1$，承重为 $m_2$；物品个数为 $n$，第 $i$ 个物品的体积为 ${w_1}_i$，质量为 ${w_2}_i$，价值为 $c_i$。在背包不过载的同时，将哪些物品装入背包可使总价值最大？\n同时枚举体积和质量即可。\n\r$$\rf[v_1,v_2] = \\max\\left\\{\\begin{aligned}\r\u0026f[v_1,v_2]\\\\\r\u0026f[v_1-{w_1}_i,v_2-{w_2}_i]+c_i,v_1≥{w_1}_i,v_2≥{w_2}_i\r\\end{aligned}\\right.\r$$\r\r时间复杂度为 $O(nm_1m_2)$。\nfor(int i = 1; i \u0026lt;= n; i ++) for(int v1 = m1; v1 \u0026gt;= w1[i]; v1 --) for(int v2 = m2; v2 \u0026gt;= w2[i]; v2 --) f[v1][v2] = max(f[v1][v2], f[v1 - w1[i]][v2 - w2[i]] + c[i]); 拓展 $  方案总数 $  在 01 背包的基础上，将物品放入背包的方案有几种？\n$g[i,v]$ 表示把前 $i$ 个物品放入体积为 $v$ 的背包的方案总数。\n  若不放第 $i$ 个物品，则方案总数为 $g[i-1,v]$；\n  若放第 $i$ 个物品，则方案总数为 $g[i,v-w_i]$。\n  $$ g[i,v]=g[i-1,v]+g[i-1,v-w_i],v≥w_i $$\n同样可以省去第一维：\n$$ g[v]=g[v]+g[v-w_i],v≥w_i $$\n初始条件：$g[0]=1$。因为当背包体积为 $0$ 时只有一个方案：不装任何物品。\nfor(int i = 1; i \u0026lt;= n; i ++) for(int v = m; v \u0026gt;= w[i]; v --) g[v] += g[v - w[i]; 最优方案总数 $  使总价值最大的方案有几种？\n已知 01 背包的状态转移方程：\n\r$$\rf[i,v] = \\max\\left\\{\\begin{aligned}\r\u0026f[i-1,v]\\\\\r\u0026f[i-1,v-w_i]+c_i,v≥w_i\r\\end{aligned}\\right.\r$$\r\r$g[i,v]$ 表示把前 $i$ 个物品放入体积为 $v$ 的背包的方案总数。\n  若 $f[i-1,v]\u0026gt;f[i-1,v-w_i]+c_i$，不放物品 $i$ 总价值最大，$g[i,v]=g[i-1,v]$；\n  若 $f[i-1,v]\u0026lt;f[i-1,v-w_i]+c_i$，放物品 $i$ 总价值最大，$g[i,v]=g[i-1,v-w_i]$；\n  若相等，则放或不放都可使总价值最大，$g[i,v]=g[i-1,v]+g[i-1,v-w_i]$。\n  for(int i = 1; i \u0026lt;= n; i ++) { for(int v = 0; v \u0026lt; w[i]; v ++) f[i][v] = f[i - 1][v], g[i][v] = g[i - 1][v]; for(int v = m; v \u0026gt;= w[i]; v --) { f[i][v] = max(f[i - 1][v], f[i - 1][v - w[i]] + c[i]); if(f[i][v] == f[i - 1][v]) g[i][v] += g[i - 1][v]; if(f[i][v] == f[i - 1][v - w[i]] + c[i]) g[i][v] += g[v - w[i]]; } } 一维优化版：\nfor(int i = 1; i \u0026lt;= n; i ++) for(int v = m; v \u0026gt;= w[i]; v --) { int max_f = max(f[v], f[v - w[i]] + c[i]), max_g = 0; if(max_f == f[v]) max_g += g[v]; if(max_f == f[v - w[i]] + c[i]) max_g += g[v - w[i]]; f[v] = max_f, g[v] = max_g; } "}),a.add({id:8,href:'/docs/DP/interval/',title:"区间 DP",section:"动态规划",content:"引出问题 $  $n$ 堆石子排成一列，第 $i$ 堆石子重量为 $A_i$。每次合并相邻两堆石子为一堆，消耗的体力值为这两堆石子的重量和。求将所有石子合并为一堆，最少消耗多少体力。\n基本原理 $  $f[l,r]$ 表示合并区间 $[l,r]$ 内的石子（第 $l$ 堆至第 $r$ 堆石子）花费的最少体力值。\n枚举 $k=l→r-1$：\n  合并区间 $[l,k]$ 内的石子为一堆石子，消耗体力值 $f[l,k]$；\n  合并区间 $[k+1,r]$ 内的石子为一堆石子，消耗体力值 $f[k+1,r]$；\n  合并剩下两堆石子，消耗体力值 $A_l+A_{l+1}+\\cdots+A_r$。\n  $$ f[l,r]=\\min_{l≤k\u0026lt;r}{f[l,k]+f[k+1,r]}+\\sum_{i=l}^r A_i $$\n使用 前缀和 进一步优化查询区间石子质量和的效率：\n$$ f[l,r]=\\min_{l≤k\u0026lt;r}{f[l,k]+f[k+1,r]}+sum[r]-sum[l-1] $$\n由于大区间的「最少体力值」由小区间推出，故计算顺序为从小区间到大区间。\n枚举区间长度 $len=2→n$，每次计算所有长度为 $len$ 的区间的「最少体力值」。\n   初始条件 $f[i,i]=0$，其余为 $∞$ 计算顺序 $f[$小区间$]→f[$大区间$]$     最终答案 $f[1,n]$ 时间复杂度 $O(n^3)$    \r.th {\rfont-weight: normal;\r}\r\rmemset(f, 0x7f, sizeof f); for(int i = 1; i \u0026lt;= n; i ++) { f[i][i] = 0; sum[i] = sum[i - 1] + a[i]; } for(int len = 2; len \u0026lt;= n; len ++) // 区间长度  for(int l = 1; l + len - 1 \u0026lt;= n; l ++) { // 枚举区间左端点  int r = l + len - 1; // 区间右端点  for(int k = l; k \u0026lt; r; k ++) f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]); f[l][r] += sum[r] - sum[l - 1]; } "}),a.add({id:9,href:'/docs/Basics/zip/',title:"状态压缩",section:"基础算法",content:"简介 $  将长度为 $m$ 的 $bool$ 数组用一个 $m$ 位二进制整数表示，该整数的第 $i$ 位对应原数组第 $i$ 个元素。\n\r   操作 运算     取出二进制数 $n$ 的第 $k$ 位 (n \u0026gt;\u0026gt; (k - 1)) \u0026amp; 1   将二进制数 $n$ 的第 $k$ 位取反 n ^ (1 \u0026lt;\u0026lt; (k - 1))   将二进制数 $n$ 的第 $k$ 位赋值为 $1$ `n   将二进制数 $n$ 的第 $k$ 位赋值为 $0$ n \u0026amp; (~(1 \u0026lt;\u0026lt; (k - 1)))    可以直接使用 STL Bitset。\n成对变换 $    若 $n\u0026gt;0$ 为偶数，则 $n \\ \\rm xor \\ 1=n+1$；\n  若 $n\u0026gt;0$ 为奇数，则 $n \\ \\rm xor \\ 1=n-1$。\n  因此，「$0$ 与 $1$」，「$2$ 与 $3$」，「$4$ 与 $5$」，$\\cdots$ 关于 $\\rm xor \\ 1$ 运算构成「成对变换」。\nLowbit 运算 $  $lowbit(n)$ 为 $n$ 在二进制表示下「最低位的 $1$ 和其后所有的 $0$」构成的数。例如 $n=(101000)_2$，$lowbit(n)=(1000)_2$。\n$n[i]$：$n$ 在二进制表示下的第 $i$ 位数字。假设 $n[k]=1$，$n[0\\cdots k-1]=0$。\n  将 $n$ 的每一位取反，即 $n=\\sim n$，此时 $n[k]=0$，$n[0\\cdots k-1]=1$，其它位和原来相反；\n  令 $n=n+1$，此时 $n[k]=1$，$n[0\\cdots k-1]=0$，其它位仍和原来相反；\n  因此 $n\\\u0026amp;(\\sim n+1)$ 仅有第 $k$ 位为 $1$。\n  由于在补码表示下 $-n=\\sim n+1$，因此：\n\r$$\rlowbit(n)=n\\\u0026(\\sim n+1)=n\\\u0026-n\r$$\r\r时间复杂度为 $O(1)$。结合样例理解。\n   $n$ $\\sim n$ $\\sim n+1$ $n\\\u0026amp;(\\sim n+1)$     $($101000$)_2$ $($010111$)_2$ $($011000$)_2$ $($001000$)_2$   $($101100$)_2$ $($010011$)_2$ $($010100$)_2$ $($000100$)_2$    "}),a.add({id:10,href:'/docs/DP/digit/',title:"数位 DP",section:"动态规划",content:"简介 $  如何统计区间 $[l,r]$ 中有多少整数符合某条件？\n  暴力算法，枚举 $[l,r]$ 中的每一个整数，逐个判断是否满足条件，此方法遇大数据必 $gg$。\n  优雅地使用数位 DP。\n  引出问题 $  统计区间 $[l,r]$（$0≤l\u0026lt;r≤100$）中有多少整数符合「相邻两个数字之差 $≥2$」。\n预处理 $  采用「试填法」：从个位填到最高位，如果第 $d$ 位填了 $i$，那么第 $d+1$ 位只能填 $[0,i-1]$ 或 $[i+1,9]$ 中的整数。\n$f[i,d]$ 表示「所有最高位为 $i$ 的 $d$ 位数中，符合条件的个数」。通过给定条件可推出：\n$$ f[i,d]=\\sum_{|k-i|≥2} f[k,d-1] $$\n   初始条件 $f[i,1]=1$ 计算顺序 $f[0→9,2→n]$     时间复杂度 $O(10^2\\log{n})$      int f[][]; for(int i = 0; i \u0026lt;= 9; i ++) f[i][1] = 1; // 初始条件 for(int d = 2; d \u0026lt;= N; d ++) // N : 位数的上限，N ≈ log(r) 	for(int i = 0; i \u0026lt;= 9; i ++) for(int k = 0; k \u0026lt;= 9; k ++) if(abs(k - i) \u0026gt;= 2) f[i][d] += f[k][d - 1]; 数位统计 $  考虑 前缀和 思想：\n$dp(n)$ 表示 $[0,n]$ 中有多少个数满足条件。$[l,r]$ 中符合条件的个数 $=dp(r)-dp(l-1)$。\n$dp(n)$ 的实现步骤：\n  提取 $n$ 每一位上的数字，存入数组 $at[ \\ ]$：\nint cap = 0, at[]; // cap : n 的位数；at[i] : n 的第 i 位数字 while(n) at[++ cap] = n % 10, n /= 10;   所有 $1\\cdots cap-1$ 位数都被包含于 $[0,n]$ 区间中。统计它们中符合条件的个数：\nint ans = 0; // ans : 符合条件的个数 for(int d = 1; d \u0026lt; cap; d ++) // d : 位数  for(int i = 1; i \u0026lt;= 9; i ++) // i : 最高位填的数  ans += f[i][d];   统计所有 $cap$ 位数中符合条件的个数。\n使用「试填法」，枚举 $d=cap→1$，从最高位填到最低位，并使填的数 $\u0026lt;n$：\n  若 $d=cap$，该位不能填 $0$，只能填 $1\\cdots at[d]-1$。统计符合条件的情况；\n  若 $d≠cap$，该位只能填 $0\\cdots at[d]-1$。统计符合条件的情况；\n 若此时 $|at[d+1]-at[d]|\u0026lt;2$，下一位无论怎么填都不符合条件，跳出循环；    若上一步未跳出循环且 $d=1$，说明 $n$ 本身也符合条件。但「试填法」最多只填到 $n-1$，故还要多算一个。\n  for(int d = cap; d \u0026gt;= 1; d --) { // d : 当前填到第 d 位  for(int i = (d == cap); i \u0026lt; at[d]; i ++) if(abs(at[d + 1] - i) \u0026gt;= 2) ans += f[i][d]; if(d != cap \u0026amp;\u0026amp; abs(at[d + 1] - at[d]) \u0026lt; 2) break; if(d == 1) ans ++; }   模板 $  int dp(int n) { // 求 [0, n] 中有几个数符合条件  if(n \u0026lt;= 0) return !n; // 特判  int cap = 0, ans = 0, at[]; while(n) at[++ cap] = n % 10, n /= 10; for(int d = 1; d \u0026lt; cap; d ++) for(int i = 1; i \u0026lt;= 9; i ++) ans += f[i][d]; for(int d = cap; d \u0026gt;= 1; d --) { for(int i = (d == cap); i \u0026lt; at[d]; i ++) if(abs(last - i) \u0026gt;= 2) ans += f[i][d]; // 条件按照题目的需要  if(d != cap \u0026amp;\u0026amp; abs(at[d + 1] - at[d]) \u0026lt; 2) break; if(d == 1) ans ++; } return ++ ans; } "}),a.add({id:11,href:'/docs/Basics/hipre/',title:"高精度",section:"基础算法",content:"简介 $  高精度是一套支持高位数的运算系统，例如求两个 114514 位数的和。\n输入 $  先输入字符串，再把每一位取出，存入数组。\nvoid init(int a[]) { memset(a, 0, sizeof a); // 清空数组 a  string s; cin \u0026gt;\u0026gt; s; a[0] = s.length(); // a[0] 用于储存数的长度  for(int i = 1; i \u0026lt;= a[0]; i ++) a[i] = s[a[0] - i] - \u0026#39;0\u0026#39;; // 将字符串倒序储存，便于按位计算 } 也可以逐个读入字符。\nvoid init(int a[]) { memset(a, 0, sizeof a); int i = 0; char s = getchar(); while(s \u0026lt; \u0026#39;0\u0026#39; || s \u0026gt; \u0026#39;9\u0026#39;) s = getchar(); while(s \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s \u0026lt;= \u0026#39;9\u0026#39;) a[++ i] = s – \u0026#39;0\u0026#39;, s = getchar(); a[0] = i; } 比较 $  先比较位数，若位数相同则从高位到低位逐位比较。\nint cmp(int a[], int b[]) { // a \u0026gt; b 则返回 1，a \u0026lt; b 则返回 -1，否则返回 0  if(a[0] != b[0]) return a[0] \u0026gt; b[0] ? 1 : -1; for(int i = a[0]; i \u0026gt;= 1; i --) if(a[i] != b[i]) return a[i] \u0026gt; b[i] ? 1 : -1; return 0; } 高精度加法 $  从个位开始，将两个数对应位置的数字相加，超过 $10$ 要进位。\nvoid plus(int a[], int b[], int c[]) { // 将 a + b 的结果存入 c  memset(c, 0, sizeof c); c[0] = max(a[0], b[0]); for(int i = 1; i \u0026lt;= c[0]; i ++) { c[i] += a[i] + b[i]; if(c[i] \u0026gt;= 10) // 进 1  c[i + 1] += 1, c[i] %= 10; } while(c[c[0] + 1] != 0) c[0] ++; // 修正位数 } 高精度减法 $  从个位开始，将两个数对应位置的数字相减，小于 $0$ 要借位。\nvoid minus(int a[], int b[], int c[]) { // 将 a - b 的结果存入 c  memset(c, 0, sizeof c); c[0] = max(a[0], b[0]); for(int i = 1; i \u0026lt;= c[0]; i ++) { if(a[i] \u0026lt; b[i]) // 借位  a[i + 1] --, a[i] += 10; c[i] = a[i] - b[i]; } while(c[c[0]] == 0 \u0026amp;\u0026amp; c[0] \u0026gt;= 1) c[0] --; // 修正位数 } 高精度乘法 $  高精 × 低精 $  从个位开始，将高精度数的每一位乘以低精度数，超过 $10$ 要进位。\nWarning\n高精度乘法的进位可能非常大，按位乘完后还要处理多余的进位。\n void mult(int a[], int b, int c[]) { // 将 a × b 的结果存入 c  memset(c, 0, sizeof c); c[0] = a[0]; for(int i = 1; i \u0026lt;= a[0]; i ++) { c[i] += a[i] * b; if(c[i] \u0026gt;= 10) c[i + 1] += c[i] / 10, c[i] /= 10; } while(c[c[0] + 1]) // 处理多余的进位  c[c[0] + 1] += c[c[0]] / 10, c[c[0]] /= 10, c[0] ++; } 高精 × 高精 $  做竖式乘法时，$a$ 的第 $i$ 位乘 $b$ 的第 $j$ 位最终会加在答案的第 $i+j-1$ 位上。\n\rWarning\n计算结束后要去掉最高位多余的 $0$。\n void mult(int a[], int b[], int c[]) { // 将 a × b 的结果存入 c  memset(c, 0, sizeof c); c[0] = a[0] + b[0]; int d; // 用于存放进位  for(int i = 1; i \u0026lt;= a[0]; i ++) { d = 0; for(int j = 1; j \u0026lt;= b[0]; j ++) { c[i + j - 1] += a[i] * b[j] + d; d = c[i + j - 1] / 10, c[i + j - 1] %= 10; } c[i + b[0]] = d; // 多余的进位  } while(c[c[0]] == 0 \u0026amp;\u0026amp; c[0] \u0026gt; 1) c[0] --; // 去掉最高位多余的 0 } 高精度除法 $  做竖式除法时，将除数的最高位和被除数对齐，逐位「试商」，如下图（空位已用 $0$ 填补）：\n\r高精度除法步骤：\n  将除数的最高位和被除数对齐；\n  将被除数一直减去除数，直到被除数 \u0026lt; 除数，记录减的次数；\n  重复上两步，直到除到个位；\n  按顺序输出减的次数，得到整个式子的商。最后的被除数是余数。\n  Warning\n  计算结束后要去掉最高位多余的 $0$。\n  样例程序的 $dev()$ 函数执行结束后，数组 $a$ 存储的数变为 $a÷b$ 的余数。\n   void shift(int a[], int d) { // 在 a 的后面补 d 个 0（若 d \u0026lt; 0 则去掉|d|个 0）  int b[100001] = {}; for(int i = a[0] + d; i \u0026gt;= max(0, 1 + d); i --) b[i] = a[i - d]; a[0] += d; for(int i = 1; i \u0026lt;= max(a[0], a[0] - d); i ++) a[i] = b[i]; } void dev(int a[], int b[], int c[]) { // 将 a ÷ b 的结果存入 c  memset(c, 0, sizeof c); if(b[0] == 1 \u0026amp;\u0026amp; b[1] == 0) return; // 除数为 0 时无意义  if(cmp(a, b) == -1) { // 被除数 \u0026lt; 除数时，商为 0  c[0] = 1, c[1] = 0; return; } c[0] = a[0] - b[0] + 1; shift(b, a[0] - b[0]); // 调整 b 的位数，使 b 和 a 对齐  for(int i = c[0]; i \u0026gt;= 1; i --) { while(cmp(a, b) \u0026gt;= 0) { // 用高精度减法模拟「试商」  c[i] ++; for(int j = 1; j \u0026lt;= a[0]; j ++) { if(a[j] \u0026lt; b[j]) a[j + 1] --, a[j] += 10; a[j] -= b[j]; } while(a[a[0]] == 0 \u0026amp;\u0026amp; a[0] \u0026gt; 1) a[0] --; // 去掉最高位多余的 0  } shift(b, -1); // 将 b 减小一位，和新的被除数对齐  } while(c[c[0]] == 0 \u0026amp;\u0026amp; c[0] \u0026gt; 1) c[0]--; // 去掉最高位多余的 0 } 输出 $  数据是倒序储存的，故倒序输出：\nvoid print(int a[]) { for(int i = a[0]; i \u0026gt;= 1; i --) printf(\u0026#34;%d\u0026#34;, a[i]); printf(\u0026#34;\\n\u0026#34;); } "}),a.add({id:12,href:'/docs/DP/tree/',title:"树形 DP",section:"动态规划",content:'简介 $  树形 DP 所解决的问题基于「树形结构」。例如：给出一个家族的族谱，求任意两个成员的公共祖先。这里的族谱就是一种「树形结构」。\n\r引出问题 $  给定一棵 $n$ 个点，$m$ 条边，顶点编号为 $1\\sim n$ 的无权树，$1$ 号节点为根。以 $i$ 号节点为根的子树有几个节点？\n基本原理 $  $f[i]$ 表示以节点 $i$ 为根的子树大小，$Son(i)$ 表示 $i$ 的子节点集合。易知：\n$$ f[i]=1+\\sum_{v\\in Son(i)}f[v] $$\n$f[i]$ 由 $f[i$ 的子节点$]$ 推出，计算顺序应为 $f[$子节点$]→f[$父节点]。使用记忆化搜索。\nvector\u0026lt;int\u0026gt; son[]; // son[u] : 节点 u 的子节点集合  void dfs(int u) { // 求以 u 为根的子树中节点个数  f[u] = 1; for(int i = 0; i \u0026lt; son[u].size(); i ++) { int v = son[u][i]; // 节点 u 的第 i 个子节点  dfs(v); f[u] += f[v]; } } 例题 $  没有上司的舞会 $  公司有 $n$ 个人（编号 $1\\cdots n$），现要举⾏⼀场晚会，并规定如果邀请了某个⼈，那么⼀定不会邀请他的上司（他上司的上司，上司的上司的上司 $\\cdots$ 都可以邀请）。\n每个⼈都有⼀个欢乐值，给出公司所有人的上下级关系，求⼀个邀请⽅案，使欢乐值的和最⼤。\n$f[i,j]$ 表示从以 $i$ 为根的子树中邀请部分职员参会的最欢乐值之和，当 $j=0$ 时 $i$ 号员工不参会，$j=1$ 时参会。\n  若 $i$ 号员工的下属 $v$ 不参会，则总欢乐值为 $f[v,0]$；\n  若 $i$ 号员工的下属 $v$ 参会，则总欢乐值为 $f[v,1]$。\n  显然，若 $i$ 号员工参会，他的直接下属必不来：\n$$f[i,1]=H_i+\\sum_{v\\in Son(i)}f[v,0]$$\n若 $i$ 号员工参会，他的直接下属爱来不来：\n$$f[i,0]=\\sum_{v\\in Son(i)}\\max{f[v,0],f[v,1]}$$\nvoid dfs(int u) { // 求出 u 号员工对应的 f[u][0] 和 f[u][1]  f[u][1] = h[u]; for(v = u 的每个子节点) { dfs(v); f[u][1] += f[v][0]; f[u][0] += max(f[v][0], f[v][1]); } } 树形 DP + 背包 DP $  处理某些问题时，需要结合树形 DP 和 背包 DP 的思想。\n现有 $n$ 门课程，第 $i$ 门课程的学分为 $s_i$，每门课程有 $0$ 或 $1$ 门先修课。有先修课的课程需要先学完先修课，才能学习该课程。求学习 $m$ 门课程能获得的最多学分。\n将每门课程看作树中的节点，$a→b$ 代表 $a$ 比 $b$ 先修：\n mermaid.initialize({ "flowchart": { "useMaxWidth":true }, "theme": "default" } ) graph TB\r2((2))--1((1))\r2((2))--4((4))\r2((2))--7((7))\r7((7))--5((5))\r7((7))--6((6))\r3((3))\r为了方便解决问题，新增 $0$ 号节点，使其指向所有无先修课的课程：\ngraph TB\r0((0))--2((2))\r0((0))--3((3))\r2((2))--1((1))\r2((2))--4((4))\r2((2))--7((7))\r7((7))--5((5))\r7((7))--6((6))\r3((3))\r$f[u,j]$ 表示以 $u$ 为根节点，选 $j$ 个节点，获得的最大学分。\n$dfs(u)$ 的功能是算出以 $u$ 为根节点时，分别选 $0\\sim m$ 个节点时能获得的最大学分。\n执行 $dfs(u)$ 时，枚举 $u$ 的子节点 $v$，在内层循环枚举选取的节点数 $j=m→1$：\n  将 $j$ 个节点分成两组，一组 $k$ 个，另一组 $j-k$ 个；\n  将第一组 $k$ 个节点放在以 $v$ 为根节点的子树中，最大学分为 $f[v][k]$；\n  将第二组 $j-k$ 个节点放在以 $u$ 为根节点的子树中，但不放在以 $v$ 为根节点的子树中，最大学分为 $f[u][j-k]$。\n  $$ f[u,j]=\\max_{v\\in Son(u)}{f[u,j],f[u,j-k]+f[v,k]} $$\n   初始条件 $f[i,1]=s[i]$ 边界条件 $f[0,m]$     时间复杂度 $O(n^3)$      在主程序中执行 $dfs(0)$ 后输出 $f[0,m]$ 即可。\nvoid dfs(int u) { f[u][1] = s[u]; for(int i = 0; i \u0026lt; son[u].size(); i ++) { int v = son[u][i]; dfs(v); for(int j = m; j \u0026gt;= 1; j --) for(int k = j - 1; k \u0026gt; 0; k --) f[u][j] = max(f[u][j], f[v][k] + f[u][j - k]); } } '})})()