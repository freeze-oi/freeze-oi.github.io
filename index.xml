<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>首页 on Freeze&#39;s Blogs</title>
    <link>https://freeze.org.cn/</link>
    <description>Recent content in 首页 on Freeze&#39;s Blogs</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://freeze.org.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>广度优先搜索</title>
      <link>https://freeze.org.cn/docs/Basics/bfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/bfs/</guid>
      <description>简介 $  广度优先搜索（Breadth First Search，简称 BFS）按照层次顺序查找节点，如下图：
  访问节点 0（根节点）；
  访问节点 0 的所有子结点（结点 1、2）；
  访问节点 1、2 的所有子结点（结点 3、4、5）；
$\cdots \ \cdots$
  重复访问子结点的操作，直到访问到目标节点。
基本原理 $    定义一个队列，用于存放节点编号；
  将根节点编号插入队尾（入队）；
  将队头的所有子节点入队，移除队头元素（出队），重复直到队列为空。
  Warning
为了避免重复访问同一节点，已经进过队列的结点不能再次入队。
 bool vis[]; // vis[i] 代表节点 i 是否进过队列  void bfs(int s, int e) { // 在根节点为 s 的图中找到节点 e memset(vis, false, sizeof vis); queue&amp;lt;int&amp;gt; Q; Q.</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://freeze.org.cn/docs/DP/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/intro/</guid>
      <description>简介 $  动态规划（DP） 是「打表」的最高境界，原理和考试时查草稿差不多。
假如一道填空题需要求 $1024×768$，正常学生会在草稿纸上计算出它的值 $=768432$。
此时某道应用题中再次出现了 $1024×768$：
部分学生会在打过的草稿里找到 $1024×768=768432$，直接抄进答题卡，省得再计算。更专业的学生会把草稿打成表格，方便查表和检验。
动态规划将「草稿纸」的参考性利用到极致，极大提高解题效率。
基本原理 $  例题
斐波那契数列是形如 $1, 1, 2, 3, 5, 8, \cdots$ 的数列。求数列的第 $n$ 项。
 $f[n]$ 表示数列的第 $n$ 项，则：
$$f[n]=\left\{\begin{aligned}&amp; 1, n=1, 2\\&amp; f[n-1]+f[n-2], n≥3\end{aligned}\right.$$先把特殊的 $f[1]=f[2]=1$ 填进表：
   $f[1]$ $f[2]$     $1$ $1$    根据公式计算 $f[3]$ 时，需要用到 $f[1]$ 和 $f[2]$。在表中查找它们的值，代入计算：</description>
    </item>
    
    <item>
      <title>深度优先搜索</title>
      <link>https://freeze.org.cn/docs/Basics/dfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/dfs/</guid>
      <description>简介 $  深度优先搜索（Depth First Search，简称 DFS）在查找节点时，尽可能往更深处搜索，如下图：
基本原理 $  DFS 算法在本质上是一种递归：
  若当前结点为目标结点，直接返回；
  递归搜索当前结点的每个子节点。
  void dfs(int s, int e) { // 从节点 i 出发，查找结点 e  if(s == e) return; // 找到结点 e  for(int i = 结点 k 的子节点编号) dfs(i, e); // 搜索  return; // 回溯（此处可以省略） } </description>
    </item>
    
    <item>
      <title>记忆化搜索</title>
      <link>https://freeze.org.cn/docs/DP/memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/memo/</guid>
      <description>普通搜索 $  求 斐波那契数列 第 $i$ 项（$f[i]$）的深搜程序如下：
int f(int x) { if(x &amp;lt;= 2) return 1; return f(x - 1) + f(x - 2); } 执行 $f(7)$ 的调用情况如下：
随着 $n$ 的增大，$f(n)$ 的时间复杂度呈指数级增长。如果遇到大数据，你的程序就会：
记忆化搜索 $  考虑开数组 $F[ \ ]$ 保存计算结果，从而避免重复计算。
  若 $f(x)$ 未被调用，算出 $f(x)$ 的结果，并存入 $F[\text{x}]$；
  若 $f(x)$ 已经被调用过，直接返回 $F[\text{x}]$。
  和 动态规划 中的填表思想如出一辙。
int F[] = {0, 1, 1}; int f(int x) { if(F[x] !</description>
    </item>
    
    <item>
      <title>基础 DP</title>
      <link>https://freeze.org.cn/docs/DP/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/basics/</guid>
      <description>斐波那契数列 $  斐波那契数列是形如 $1,1,2,3,5,8,\cdots$ 的数列。求数列的第 $n$ 项。
$f[n]$ 表示数列的第 $n$ 项，则：
$$ f[n]=f[n-1]+f[n-2],n≥3 $$
   初始条件 $f[1]=f[2]=1$ 计算顺序 $f[3\rightarrow n]$     边界条件 $f[n]$ 时间复杂度 $O(n)$    int f[]; f[1] = f[2] = 1; for(int i = 3; i &amp;lt;= n; i ++) f[i] = f[i - 1] + f[i - 2]; 汉诺塔问题 $  汉诺塔由 $n$ 个大小不同的圆盘和三根杆子 $a,b,c$ 组成。初始时，$n$个圆盘从大到小依次套在 $a$ 杆上，如下图所示：
现在要求把 $a$ 杆上的 $n$ 个圆盘按以下规则移到 $c$ 杆上：</description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://freeze.org.cn/docs/Basics/sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/sort/</guid>
      <description>选择排序 $  每次找出第 $i$ 小的元素，与数组第 $i$ 个位置上的元素交换。时间复杂度为 $O(n^2)$。
for(int i = 1; i &amp;lt;= n; i ++) for(int j = i + 1; j &amp;lt;= n; j ++) if(a[j] &amp;lt; a[k]) swap(a[i],a[k]); 冒泡排序 $  每次检查相邻两个元素，如果前一个大于后一个，就交换它们的位置。当没有可交换的元素时，排序结束。时间复杂度为 $O(n^2)$。
在程序的执行过程中，较大的元素像气泡般「浮」到数列的末尾，故叫做冒泡排序。
while(true) { bool solve = false; for(int i = 1; i &amp;lt;= n; i ++) if(a[i] &amp;gt; a[i + 1]) swap(a[i], a[i + 1]), solve = true; if(!solve) break; } 插入排序 $  将数列分为「已排序」和「未排序」两部分，每次从「未排序」区域中选择一个元素插入「已排序」区域的正确位置。时间复杂度为 $O(n^2)$。</description>
    </item>
    
    <item>
      <title>二分算法</title>
      <link>https://freeze.org.cn/docs/Basics/binary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/binary/</guid>
      <description>简介 $  玩过「数字炸弹」游戏吗？
  叫你的朋友在你背后写一个 $[1,1000]$ 中的正整数 $n$；
  每轮你都会给出数字 $x$，你朋友只能回答「$n$ 比 $x$ 大」「$n$ 比 $x$ 小」或「猜中」。
  一旦猜中，数字炸弹就会爆炸。你能求出引爆炸弹的最少次数吗？
最初 $n∈(0,1001)$。你可以先猜 $500$：
  若 $n&amp;gt;500$，则可以进一步确定 $n∈(500,1001)$；
  若 $n&amp;lt;500$，则可以进一步确定 $n∈(0,500)$；
  否则 $n=500$，猜中。
  重复猜范围的中间数，每次都会将 $n$ 的范围缩小一半，最多 $\log{n}$ 次就可以确定 $n$ 的值。
通过若干次折半范围实现快速查询，是二分算法的基本思想。
基本原理 $  $l$ 表示 $n$ 所在范围的左端点，$r$ 表示右端点，即 $n∈(l,r)$。重复执行以下操作：
  取范围的中间数 $m=\lfloor(l+r)/2\rfloor$；
  若 $n&amp;gt;m$，则可以确定 $n∈(m,r)$，令 $l=m$；
  若 $n&amp;lt;m$，则可以确定 $n∈(l,m)$，令 $r=m$；</description>
    </item>
    
    <item>
      <title>背包 DP</title>
      <link>https://freeze.org.cn/docs/DP/knap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/knap/</guid>
      <description>01 背包 $  用体积为 $m$ 的背包装 $n$ 种物品，每种物品只有 $1$ 个。第 $i$ 种物品的体积为 $w_i$，价值为 $c_i$，将哪些物品装入背包可使总价值最大？
$f[i,v]$ 表示把前 $i$ 个物品（部分或全部）放入体积为 $v$ 的背包，可以获得的最大总价值。
若只考虑第 $i$ 个物品的策略（放或不放），则问题转而只涉及到前 $i-1$ 个物品：
  若不放第 $i$ 个物品，则 $f[i,v]=f[i-1,v]$；
  若放第 $i$ 个物品，则前 $i-1$ 个物品只能放在体积为 $v-w_i$ 的空间里，故 $f[i,v]=f[i-1,v-w_i]+c_i$。
  $$f[i,v] = \max\left\{\begin{aligned}&amp;f[i-1,v]\\&amp;f[i-1,v-w_i]+c_i,v≥w_i\end{aligned}\right.$$由于 $f[i,v]$ 的值只由 $f[i-1,v]$ 和 $f[i-1,v-w_i]$ 决定，所以先求 $f[1,0\cdots m]$，再求 $f[2,0\cdots m]$，$\cdots$，直到求出 $f[n,m]$。时间复杂度为 $O(nm)$。
Warning
当 $v &amp;lt; w_i$ 时，第 $i$ 个物品放不进体积为 $v$ 的背包，此时 $f[i,v]$ 只能等于 $f[i-1,v]$。</description>
    </item>
    
    <item>
      <title>区间 DP</title>
      <link>https://freeze.org.cn/docs/DP/interval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/interval/</guid>
      <description>引出问题 $  $n$ 堆石子排成一列，第 $i$ 堆石子重量为 $A_i$。每次合并相邻两堆石子为一堆，消耗的体力值为这两堆石子的重量和。求将所有石子合并为一堆，最少消耗多少体力。
基本原理 $  $f[l,r]$ 表示合并区间 $[l,r]$ 内的石子（第 $l$ 堆至第 $r$ 堆石子）花费的最少体力值。
枚举 $k=l→r-1$：
  合并区间 $[l,k]$ 内的石子为一堆石子，消耗体力值 $f[l,k]$；
  合并区间 $[k+1,r]$ 内的石子为一堆石子，消耗体力值 $f[k+1,r]$；
  合并剩下两堆石子，消耗体力值 $A_l+A_{l+1}+\cdots+A_r$。
  $$ f[l,r]=\min_{l≤k&amp;lt;r}{f[l,k]+f[k+1,r]}+\sum_{i=l}^r A_i $$
使用 前缀和 进一步优化查询区间石子质量和的效率：
$$ f[l,r]=\min_{l≤k&amp;lt;r}{f[l,k]+f[k+1,r]}+sum[r]-sum[l-1] $$
由于大区间的「最少体力值」由小区间推出，故计算顺序为从小区间到大区间。
枚举区间长度 $len=2→n$，每次计算所有长度为 $len$ 的区间的「最少体力值」。
   初始条件 $f[i,i]=0$，其余为 $∞$ 计算顺序 $f[$小区间$]→f[$大区间$]$     最终答案 $f[1,n]$ 时间复杂度 $O(n^3)$    .</description>
    </item>
    
    <item>
      <title>状态压缩</title>
      <link>https://freeze.org.cn/docs/Basics/zip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/zip/</guid>
      <description>简介 $  将长度为 $m$ 的 $bool$ 数组用一个 $m$ 位二进制整数表示，该整数的第 $i$ 位对应原数组第 $i$ 个元素。
   操作 运算     取出二进制数 $n$ 的第 $k$ 位 (n &amp;gt;&amp;gt; (k - 1)) &amp;amp; 1   将二进制数 $n$ 的第 $k$ 位取反 n ^ (1 &amp;lt;&amp;lt; (k - 1))   将二进制数 $n$ 的第 $k$ 位赋值为 $1$ `n   将二进制数 $n$ 的第 $k$ 位赋值为 $0$ n &amp;amp; (~(1 &amp;lt;&amp;lt; (k - 1)))    可以直接使用 STL Bitset。</description>
    </item>
    
    <item>
      <title>数位 DP</title>
      <link>https://freeze.org.cn/docs/DP/digit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/digit/</guid>
      <description>简介 $  如何统计区间 $[l,r]$ 中有多少整数符合某条件？
  暴力算法，枚举 $[l,r]$ 中的每一个整数，逐个判断是否满足条件，此方法遇大数据必 $gg$。
  优雅地使用数位 DP。
  引出问题 $  统计区间 $[l,r]$（$0≤l&amp;lt;r≤100$）中有多少整数符合「相邻两个数字之差 $≥2$」。
预处理 $  采用「试填法」：从个位填到最高位，如果第 $d$ 位填了 $i$，那么第 $d+1$ 位只能填 $[0,i-1]$ 或 $[i+1,9]$ 中的整数。
$f[i,d]$ 表示「所有最高位为 $i$ 的 $d$ 位数中，符合条件的个数」。通过给定条件可推出：
$$ f[i,d]=\sum_{|k-i|≥2} f[k,d-1] $$
   初始条件 $f[i,1]=1$ 计算顺序 $f[0→9,2→n]$     时间复杂度 $O(10^2\log{n})$      int f[][]; for(int i = 0; i &amp;lt;= 9; i ++) f[i][1] = 1; // 初始条件 for(int d = 2; d &amp;lt;= N; d ++) // N : 位数的上限，N ≈ log(r) 	for(int i = 0; i &amp;lt;= 9; i ++) for(int k = 0; k &amp;lt;= 9; k ++) if(abs(k - i) &amp;gt;= 2) f[i][d] += f[k][d - 1]; 数位统计 $  考虑 前缀和 思想：</description>
    </item>
    
    <item>
      <title>高精度</title>
      <link>https://freeze.org.cn/docs/Basics/hipre/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/hipre/</guid>
      <description>简介 $  高精度是一套支持高位数的运算系统，例如求两个 114514 位数的和。
输入 $  先输入字符串，再把每一位取出，存入数组。
void init(int a[]) { memset(a, 0, sizeof a); // 清空数组 a  string s; cin &amp;gt;&amp;gt; s; a[0] = s.length(); // a[0] 用于储存数的长度  for(int i = 1; i &amp;lt;= a[0]; i ++) a[i] = s[a[0] - i] - &amp;#39;0&amp;#39;; // 将字符串倒序储存，便于按位计算 } 也可以逐个读入字符。
void init(int a[]) { memset(a, 0, sizeof a); int i = 0; char s = getchar(); while(s &amp;lt; &amp;#39;0&amp;#39; || s &amp;gt; &amp;#39;9&amp;#39;) s = getchar(); while(s &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; s &amp;lt;= &amp;#39;9&amp;#39;) a[++ i] = s – &amp;#39;0&amp;#39;, s = getchar(); a[0] = i; } 比较 $  先比较位数，若位数相同则从高位到低位逐位比较。</description>
    </item>
    
    <item>
      <title>树形 DP</title>
      <link>https://freeze.org.cn/docs/DP/tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/tree/</guid>
      <description>简介 $  树形 DP 所解决的问题基于「树形结构」。例如：给出一个家族的族谱，求任意两个成员的公共祖先。这里的族谱就是一种「树形结构」。
引出问题 $  给定一棵 $n$ 个点，$m$ 条边，顶点编号为 $1\sim n$ 的无权树，$1$ 号节点为根。以 $i$ 号节点为根的子树有几个节点？
基本原理 $  $f[i]$ 表示以节点 $i$ 为根的子树大小，$Son(i)$ 表示 $i$ 的子节点集合。易知：
$$ f[i]=1+\sum_{v\in Son(i)}f[v] $$
$f[i]$ 由 $f[i$ 的子节点$]$ 推出，计算顺序应为 $f[$子节点$]→f[$父节点]。使用记忆化搜索。
vector&amp;lt;int&amp;gt; son[]; // son[u] : 节点 u 的子节点集合  void dfs(int u) { // 求以 u 为根的子树中节点个数  f[u] = 1; for(int i = 0; i &amp;lt; son[u].size(); i ++) { int v = son[u][i]; // 节点 u 的第 i 个子节点  dfs(v); f[u] += f[v]; } } 例题 $  没有上司的舞会 $  公司有 $n$ 个人（编号 $1\cdots n$），现要举⾏⼀场晚会，并规定如果邀请了某个⼈，那么⼀定不会邀请他的上司（他上司的上司，上司的上司的上司 $\cdots$ 都可以邀请）。</description>
    </item>
    
  </channel>
</rss>
