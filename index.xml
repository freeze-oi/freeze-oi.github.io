<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>首页 on Freeze&#39;s Blogs</title>
    <link>https://freeze.org.cn/</link>
    <description>Recent content in 首页 on Freeze&#39;s Blogs</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://freeze.org.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>广度优先搜索</title>
      <link>https://freeze.org.cn/docs/Basics/bfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/bfs/</guid>
      <description>简介 $  广度优先搜索（Breadth First Search，简称 BFS）按照层次顺序查找节点，如下图：
  访问节点 0（根节点）；
  访问节点 0 的所有子结点（结点 1、2）；
  访问节点 1、2 的所有子结点（结点 3、4、5）；
$\cdots \ \cdots$
  重复访问子结点的操作，直到访问到目标节点。
基本原理 $    定义一个队列，用于存放节点编号；
  将根节点编号插入队尾（入队）；
  将队头的所有子节点入队，移除队头元素（出队），重复直到队列为空。
  Warning
为了避免重复访问同一节点，已经进过队列的结点不能再次入队。
 bool vis[]; // vis[i] 代表节点 i 是否进过队列  void bfs(int s, int e) { // 在根节点为 s 的图中找到节点 e memset(vis, false, sizeof vis); queue&amp;lt;int&amp;gt; Q; Q.</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://freeze.org.cn/docs/DP/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/intro/</guid>
      <description>简介 $  动态规划（DP） 是「打表」的最高境界，原理和考试时查草稿差不多。
假如一道填空题需要求 $1024×768$，正常学生会在草稿纸上计算出它的值 $=768432$。
此时某道应用题中再次出现了 $1024×768$：
部分学生会在打过的草稿里找到 $1024×768=768432$，直接抄进答题卡，省得再计算。更专业的学生会把草稿打成表格，方便查表和检验。
动态规划将「草稿纸」的参考性利用到极致，极大提高解题效率。
基本原理 $  例题
斐波那契数列是形如 $1, 1, 2, 3, 5, 8, \cdots$ 的数列。求数列的第 $n$ 项。
 $f[n]$ 表示数列的第 $n$ 项，则：
$$f[n]=\left\{\begin{aligned}&amp; 1, n=1, 2\\&amp; f[n-1]+f[n-2], n≥3\end{aligned}\right.$$先把特殊的 $f[1]=f[2]=1$ 填进表：
   $f[1]$ $f[2]$     $1$ $1$    根据公式计算 $f[3]$ 时，需要用到 $f[1]$ 和 $f[2]$。在表中查找它们的值，代入计算：</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://freeze.org.cn/docs/DS/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DS/intro/</guid>
      <description>概念 $  数据结构是计算机储存、组织数据的方式，分为逻辑结构和物理结构。
逻辑结构 $  数据元素之间的逻辑关系，分为以下四种：
1. 线性结构 $  线性结构用于将元素按照某种顺序排列成「一条线」。
2. 集合结构 $  集合结构用于分类元素，同类元素置于同个集合。如下图，$2,4,5,8,\textbf{♂}$ 为同类元素，$1,3,6,7$ 为同类元素。
3. 树形结构 $  树形结构的元素存在「一对多」的层次关系，适用于描述「上下级」关系，在 图论中有详细介绍。
4. 图形结构 $  图形结构的元素存在「多对多」的关系，适用于描述「城市道路连通」关系，在 图论中有详细介绍。
物理结构 $  元素在储存器中的储存方式，分为以下两种：
1. 顺序结构 $  我们熟知的「数组」就是顺序结构，将元素存于一段连续内存中。
顺序结构具有以下性质：
  支持随机访问元素；
  不支持插入元素。
  相当于食堂打饭排队，大家都按顺序排好，每个人占一小段空间，谁也不插队。
2. 链式结构 $  链式结构把元素存于任意内存单元（不一定连续），用指针存放关联元素的地址。
链式机构具有以下性质：
  不支持随机访问元素；
  支持插入元素。
  事实上食堂总会有人插队，相当于在两个元素之间插入一个元素。</description>
    </item>
    
    <item>
      <title>栈</title>
      <link>https://freeze.org.cn/docs/DS/stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DS/stack/</guid>
      <description>简介 $  栈是一种「先进后出」的数据结构。类似于在桶中堆积物品，取物品时只能从顶端开始取，最先进桶的被压在最底下，最后被取出来。基本操作见 STL Stack。
表达式计算 $  算术表达式分为三类（$op$ 为运算符，$A,B$ 为数字或表达式）：
  中缀表达式：全国人民都在用的表达式，如「$5×(3+2)$」；
  前缀表达式：形如「$op \ \textcolor{red}{A} \ \textcolor{blue}{B}$」，如「$× \ \textcolor{red}{5} \ \textcolor{blue}{+} \ \textcolor{blue}{3} \ \textcolor{blue}{2}$」；
  后缀表达式：形如「$\textcolor{red}{A} \ \textcolor{blue}{B} \ op$」，如「$\textcolor{red}{3} \ \textcolor{red}{2} \ \textcolor{red}{+} \ \textcolor{blue}{5} \ ×$」。
  计算前/后缀表达式时，先递归求出 $A,B$ 的值，二者再做 $op$ 运算。计算方案是唯一确定的，且不需要使用括号。计算后缀表达式的算法最容易设计。
后缀表达式 $    定义一个栈，用于存放数；
  逐一扫描后缀表达式中的元素：
  若扫到一个数 $n$，则把 $n$ 入栈；
  若扫到运算符 $op$ ，则弹出栈顶的两个元素，二者做 $op$ 计算。将计算结果入栈。</description>
    </item>
    
    <item>
      <title>深度优先搜索</title>
      <link>https://freeze.org.cn/docs/Basics/dfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/dfs/</guid>
      <description>简介 $  深度优先搜索（Depth First Search，简称 DFS）在查找节点时，尽可能往更深处搜索，如下图：
基本原理 $  DFS 算法在本质上是一种递归：
  若当前结点为目标结点，直接返回；
  递归搜索当前结点的每个子节点。
  void dfs(int s, int e) { // 从节点 i 出发，查找结点 e  if(s == e) return; // 找到结点 e  for(int i = 结点 k 的子节点编号) dfs(i, e); // 搜索  return; // 回溯（此处可以省略） } </description>
    </item>
    
    <item>
      <title>记忆化搜索</title>
      <link>https://freeze.org.cn/docs/DP/memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/memo/</guid>
      <description>普通搜索 $  求 斐波那契数列 第 $i$ 项（$f[i]$）的深搜程序如下：
int f(int x) { if(x &amp;lt;= 2) return 1; return f(x - 1) + f(x - 2); } 执行 $f(7)$ 的调用情况如下：
随着 $n$ 的增大，$f(n)$ 的时间复杂度呈指数级增长。如果遇到大数据，你的程序就会：
记忆化搜索 $  考虑开数组 $F[ \ ]$ 保存计算结果，从而避免重复计算。
  若 $f(x)$ 未被调用，算出 $f(x)$ 的结果，并存入 $F[\text{x}]$；
  若 $f(x)$ 已经被调用过，直接返回 $F[\text{x}]$。
  和 动态规划 中的填表思想如出一辙。
int F[] = {0, 1, 1}; int f(int x) { if(F[x] !</description>
    </item>
    
    <item>
      <title>基础 DP</title>
      <link>https://freeze.org.cn/docs/DP/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/basics/</guid>
      <description>斐波那契数列 $  斐波那契数列是形如 $1,1,2,3,5,8,\cdots$ 的数列。求数列的第 $n$ 项。
$f[n]$ 表示数列的第 $n$ 项，则：
$$ f[n]=f[n-1]+f[n-2],n≥3 $$
   初始条件 $f[1]=f[2]=1$ 计算顺序 $f[3\rightarrow n]$     边界条件 $f[n]$ 时间复杂度 $O(n)$    int f[]; f[1] = f[2] = 1; for(int i = 3; i &amp;lt;= n; i ++) f[i] = f[i - 1] + f[i - 2]; 汉诺塔问题 $  汉诺塔由 $n$ 个大小不同的圆盘和三根杆子 $a,b,c$ 组成。初始时，$n$个圆盘从大到小依次套在 $a$ 杆上，如下图所示：
现在要求把 $a$ 杆上的 $n$ 个圆盘按以下规则移到 $c$ 杆上：</description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://freeze.org.cn/docs/Basics/sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/sort/</guid>
      <description>选择排序 $  每次找出第 $i$ 小的元素，与数组第 $i$ 个位置上的元素交换。时间复杂度为 $O(n^2)$。
for(int i = 1; i &amp;lt;= n; i ++) for(int j = i + 1; j &amp;lt;= n; j ++) if(a[j] &amp;lt; a[k]) swap(a[i],a[k]); 冒泡排序 $  每次检查相邻两个元素，如果前一个大于后一个，就交换它们的位置。当没有可交换的元素时，排序结束。时间复杂度为 $O(n^2)$。
在程序的执行过程中，较大的元素像气泡般「浮」到数列的末尾，故叫做冒泡排序。
while(true) { bool solve = false; for(int i = 1; i &amp;lt;= n; i ++) if(a[i] &amp;gt; a[i + 1]) swap(a[i], a[i + 1]), solve = true; if(!solve) break; } 插入排序 $  将数列分为「已排序」和「未排序」两部分，每次从「未排序」区域中选择一个元素插入「已排序」区域的正确位置。时间复杂度为 $O(n^2)$。</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://freeze.org.cn/docs/DS/link/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DS/link/</guid>
      <description>简介 $    链表只能按顺序依次访问元素，而数组支持随机访问。
  链表支持在任意位置插入或删除元素，而数组不支持。
  链表节点 $  用一个结构体表示链表的节点，其中可以存储任意数据。另外用 prev 和 next 两个指针指向前后相邻的节点。
struct Node { int val; // 数据（可以是任意类型）  Node *prev, *next; // 指针 }; 初始化 $  初始化链表时，额外建立两个节点 head 和 tail 代表链表头尾，把实际节点存储在 head 与 tail 之间，简化链表边界的判断。
Node *head, *tail; void init() { head = new Node(); tail = new Node(); head-&amp;gt;next = tail; tail-&amp;gt;prev = next; } 插入/删除节点 $  如何在 $1$ 和 $2$ 之间插入 $3$ ？</description>
    </item>
    
    <item>
      <title>队列</title>
      <link>https://freeze.org.cn/docs/DS/queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DS/queue/</guid>
      <description>简介 $  队列是一种「先进先出」的数据结构。元素从队列的前端进入（入队），从末端离开（出队），类似于排队。基本操作见 STL Queue。
双向队列 $  队列元素只能从一端进，另一端出，有时无法满足问题的需要。双向队列应运而生，它支持从两端插入或删除元素。
双向队列的基本操作见 STL Deque。
单调队列 $  单调队列的元素从队头到队尾满足单调性，适用于查询某一动态区间的最大（或最小）元素。
插入元素 $  将 $A[i]$ 入队，维护队列单调性，同时保证队列元素在 $A[p\cdots i]$ 范围内。以单调递增队列为例：
  重复弹出队头，直到队头 $≥p$；
  重复弹出队尾，直到 $A[$队尾$]&amp;lt;A[i]$（若单调递减，则重复直到 $A[$队尾$]&amp;gt;A[i]$）。
  将 $i$ 入队。
  涉及双端操作，须使用双向队列。此时 $A[p\cdots i]$ 范围内最小元素为 $A[$队头$]$。
deque&amp;lt;int&amp;gt; q; // 存储元素下标  void insert(int i, int p) { // 将 a[i] 入队，维护队列元素在 a[p...i] 范围内  while(!q.empty() &amp;amp;&amp;amp; q.front() &amp;lt; p) q.</description>
    </item>
    
    <item>
      <title>二分算法</title>
      <link>https://freeze.org.cn/docs/Basics/binary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/binary/</guid>
      <description>简介 $  玩过「数字炸弹」游戏吗？
  叫你的朋友在你背后写一个 $[1,1000]$ 中的正整数 $n$；
  每轮你都会给出数字 $x$，你朋友只能回答「$n$ 比 $x$ 大」「$n$ 比 $x$ 小」或「猜中」。
  一旦猜中，数字炸弹就会爆炸。你能求出引爆炸弹的最少次数吗？
最初 $n∈(0,1001)$。你可以先猜 $500$：
  若 $n&amp;gt;500$，则可以进一步确定 $n∈(500,1001)$；
  若 $n&amp;lt;500$，则可以进一步确定 $n∈(0,500)$；
  否则 $n=500$，猜中。
  重复猜范围的中间数，每次都会将 $n$ 的范围缩小一半，最多 $\log{n}$ 次就可以确定 $n$ 的值。
通过若干次折半范围实现快速查询，是二分算法的基本思想。
基本原理 $  $l$ 表示 $n$ 所在范围的左端点，$r$ 表示右端点，即 $n∈(l,r)$。重复执行以下操作：
  取范围的中间数 $m=\lfloor(l+r)/2\rfloor$；
  若 $n&amp;gt;m$，则可以确定 $n∈(m,r)$，令 $l=m$；
  若 $n&amp;lt;m$，则可以确定 $n∈(l,m)$，令 $r=m$；</description>
    </item>
    
    <item>
      <title>二叉堆</title>
      <link>https://freeze.org.cn/docs/DS/heap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DS/heap/</guid>
      <description>简介 $  二叉堆（Binary Heap） 是一种基于完全二叉树的数据结构。
  小根堆：任意节点 $≥$ 其父节点，根节点最小。
  大根堆：任意节点 $≤$ 其父节点，根节点最大。
  本篇以小根堆为例，介绍二叉堆的实现方式。
构造 $  按照「从上到下，从左到右」的顺序给节点编号。
该二叉堆具有以下性质：
  $1$ 号节点是根节点。
  $u$ 号节点的父节点为 $u÷2$（向下取整）。
  $u$ 号节点的左子节点为 $2u$，右子节点为 $2u+1$。
  二叉堆的任意一条支路都按照升序排序。
  使用数组保存二叉堆。
int t[], n; // t[u] : u 号节点的值 // n : 节点总数 插入 $  如何往小根堆中插入元素 $2$？
  在堆底新建节点，值为 $2$；
  对新节点所在支路进行排序。重复执行以下步骤：</description>
    </item>
    
    <item>
      <title>背包 DP</title>
      <link>https://freeze.org.cn/docs/DP/knap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/knap/</guid>
      <description>01 背包 $  用体积为 $m$ 的背包装 $n$ 种物品，每种物品只有 $1$ 个。第 $i$ 种物品的体积为 $w_i$，价值为 $c_i$，将哪些物品装入背包可使总价值最大？
$f[i,v]$ 表示把前 $i$ 个物品（部分或全部）放入体积为 $v$ 的背包，可以获得的最大总价值。
若只考虑第 $i$ 个物品的策略（放或不放），则问题转而只涉及到前 $i-1$ 个物品：
  若不放第 $i$ 个物品，则 $f[i,v]=f[i-1,v]$；
  若放第 $i$ 个物品，则前 $i-1$ 个物品只能放在体积为 $v-w_i$ 的空间里，故 $f[i,v]=f[i-1,v-w_i]+c_i$。
  $$f[i,v] = \max\left\{\begin{aligned}&amp;f[i-1,v]\\&amp;f[i-1,v-w_i]+c_i,v≥w_i\end{aligned}\right.$$由于 $f[i,v]$ 的值只由 $f[i-1,v]$ 和 $f[i-1,v-w_i]$ 决定，所以先求 $f[1,0\cdots m]$，再求 $f[2,0\cdots m]$，$\cdots$，直到求出 $f[n,m]$。时间复杂度为 $O(nm)$。
Warning
当 $v &amp;lt; w_i$ 时，第 $i$ 个物品放不进体积为 $v$ 的背包，此时 $f[i,v]$ 只能等于 $f[i-1,v]$。</description>
    </item>
    
    <item>
      <title>区间 DP</title>
      <link>https://freeze.org.cn/docs/DP/interval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/interval/</guid>
      <description>引出问题 $  $n$ 堆石子排成一列，第 $i$ 堆石子重量为 $A_i$。每次合并相邻两堆石子为一堆，消耗的体力值为这两堆石子的重量和。求将所有石子合并为一堆，最少消耗多少体力。
基本原理 $  $f[l,r]$ 表示合并区间 $[l,r]$ 内的石子（第 $l$ 堆至第 $r$ 堆石子）花费的最少体力值。
枚举 $k=l→r-1$：
  合并区间 $[l,k]$ 内的石子为一堆石子，消耗体力值 $f[l,k]$；
  合并区间 $[k+1,r]$ 内的石子为一堆石子，消耗体力值 $f[k+1,r]$；
  合并剩下两堆石子，消耗体力值 $A_l+A_{l+1}+\cdots+A_r$。
  $$ f[l,r]=\min_{l≤k&amp;lt;r}{f[l,k]+f[k+1,r]}+\sum_{i=l}^r A_i $$
使用 前缀和 进一步优化查询区间石子质量和的效率：
$$ f[l,r]=\min_{l≤k&amp;lt;r}{f[l,k]+f[k+1,r]}+sum[r]-sum[l-1] $$
由于大区间的「最少体力值」由小区间推出，故计算顺序为从小区间到大区间。
枚举区间长度 $len=2→n$，每次计算所有长度为 $len$ 的区间的「最少体力值」。
   初始条件 $f[i,i]=0$，其余为 $∞$ 计算顺序 $f[$小区间$]→f[$大区间$]$     最终答案 $f[1,n]$ 时间复杂度 $O(n^3)$    .</description>
    </item>
    
    <item>
      <title>并查集</title>
      <link>https://freeze.org.cn/docs/DS/DSU/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DS/DSU/</guid>
      <description>简介 $  并查集 支持以下操作：
  往一个集合中加入元素；
  快速查询两个元素是否在同一集合；
  合并两个集合为一个集合。
  基本原理 $  若 $a \ b$，$e \ c$，$e \ d$ 分别在同一个集合，则一共有几个集合？$b$ 和 $d$ 是否同集？
构造并查集 $  把属于同一集合的两个节点连一起，易知集合数 $=$ 连通图数。若两个节点连通，则它们同集。
 mermaid.initialize({ &#34;flowchart&#34;: { &#34;useMaxWidth&#34;:true }, &#34;theme&#34;: &#34;default&#34; } ) flowchart TDsubgraph set 2e((e))---c((c))e((e))---d((d))endsubgraph set 1a((a))---b((b)) end并查集在每个集合中选取一个代表元素作为根节点，构造「树型结构」。如下图，$a$ 和 $e$ 分别是两个集合的代表元素。
flowchart TDsubgraph set 2e((e))--c((c))e((e))--d((d))endsubgraph set 1a((a))--b((b)) end$fa[i]$ 代表节点 $i$ 的父节点编号。如上图，$fa[b]=a$，$fa[d]=e$，$fa[c]=e$。根节点没有父节点，其 $fa$ 值都设为 $0$，如 $fa[a]=0$，$fa[e]=0$。</description>
    </item>
    
    <item>
      <title>状态压缩</title>
      <link>https://freeze.org.cn/docs/Basics/zip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/zip/</guid>
      <description>简介 $  将长度为 $m$ 的 $bool$ 数组用一个 $m$ 位二进制整数表示，该整数的第 $i$ 位对应原数组第 $i$ 个元素。
   操作 运算     取出二进制数 $n$ 的第 $k$ 位 (n &amp;gt;&amp;gt; (k - 1)) &amp;amp; 1   将二进制数 $n$ 的第 $k$ 位取反 n ^ (1 &amp;lt;&amp;lt; (k - 1))   将二进制数 $n$ 的第 $k$ 位赋值为 $1$ `n   将二进制数 $n$ 的第 $k$ 位赋值为 $0$ n &amp;amp; (~(1 &amp;lt;&amp;lt; (k - 1)))    可以直接使用 STL Bitset。</description>
    </item>
    
    <item>
      <title>数位 DP</title>
      <link>https://freeze.org.cn/docs/DP/digit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/digit/</guid>
      <description>简介 $  如何统计区间 $[l,r]$ 中有多少整数符合某条件？
  暴力算法，枚举 $[l,r]$ 中的每一个整数，逐个判断是否满足条件，此方法遇大数据必 $gg$。
  优雅地使用数位 DP。
  引出问题 $  统计区间 $[l,r]$（$0≤l&amp;lt;r≤100$）中有多少整数符合「相邻两个数字之差 $≥2$」。
预处理 $  采用「试填法」：从个位填到最高位，如果第 $d$ 位填了 $i$，那么第 $d+1$ 位只能填 $[0,i-1]$ 或 $[i+1,9]$ 中的整数。
$f[i,d]$ 表示「所有最高位为 $i$ 的 $d$ 位数中，符合条件的个数」。通过给定条件可推出：
$$ f[i,d]=\sum_{|k-i|≥2} f[k,d-1] $$
   初始条件 $f[i,1]=1$ 计算顺序 $f[0→9,2→n]$     时间复杂度 $O(10^2\log{n})$      int f[][]; for(int i = 0; i &amp;lt;= 9; i ++) f[i][1] = 1; // 初始条件 for(int d = 2; d &amp;lt;= N; d ++) // N : 位数的上限，N ≈ log(r) 	for(int i = 0; i &amp;lt;= 9; i ++) for(int k = 0; k &amp;lt;= 9; k ++) if(abs(k - i) &amp;gt;= 2) f[i][d] += f[k][d - 1]; 数位统计 $  考虑 前缀和 思想：</description>
    </item>
    
    <item>
      <title>树状数组</title>
      <link>https://freeze.org.cn/docs/DS/treearray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DS/treearray/</guid>
      <description>前置知识 $  你得先学会 $lowbit(n)$ 的计算方式。
引入问题 $  数组 $A$ 中共 $n$ 个元素，对其反复进行以下操作共 $m$ 次：
  单点修改：将 $A[ x]$ 加上 $k$。
  区间查询：查询 $A[l\cdots r]$ 的和。
  int a[]; void set(int id, int v) { // 单点修改  a[id] = v; } int ask(int l, int r) { // 区间查询  int ans = 0; for(int i = l; i &amp;lt;= r; i ++) ans += a[i]; return ans; }     暴力算法（$\textcolor{red}{×}$） 树状数组（$\textcolor{green}{√}$）     单点修改 $\textcolor{green}{O(1)}$ $\textcolor{green}{O(\log{n})}$   区间查询 $\textcolor{red}{O(n)}$ $\textcolor{green}{O(\log{n})}$   $m$ 次操作 $\textcolor{red}{O(mn)}$ $\textcolor{green}{O(m\log{n})}$    构造 $  在原数组的上方构建树型结构，每个节点表示一段区间和：</description>
    </item>
    
    <item>
      <title>高精度</title>
      <link>https://freeze.org.cn/docs/Basics/hipre/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/Basics/hipre/</guid>
      <description>简介 $  高精度是一套支持高位数的运算系统，例如求两个 114514 位数的和。
输入 $  先输入字符串，再把每一位取出，存入数组。
void init(int a[]) { memset(a, 0, sizeof a); // 清空数组 a  string s; cin &amp;gt;&amp;gt; s; a[0] = s.length(); // a[0] 用于储存数的长度  for(int i = 1; i &amp;lt;= a[0]; i ++) a[i] = s[a[0] - i] - &amp;#39;0&amp;#39;; // 将字符串倒序储存，便于按位计算 } 也可以逐个读入字符。
void init(int a[]) { memset(a, 0, sizeof a); int i = 0; char s = getchar(); while(s &amp;lt; &amp;#39;0&amp;#39; || s &amp;gt; &amp;#39;9&amp;#39;) s = getchar(); while(s &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; s &amp;lt;= &amp;#39;9&amp;#39;) a[++ i] = s – &amp;#39;0&amp;#39;, s = getchar(); a[0] = i; } 比较 $  先比较位数，若位数相同则从高位到低位逐位比较。</description>
    </item>
    
    <item>
      <title>树形 DP</title>
      <link>https://freeze.org.cn/docs/DP/tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DP/tree/</guid>
      <description>简介 $  树形 DP 所解决的问题基于「树形结构」。例如：给出一个家族的族谱，求任意两个成员的公共祖先。这里的族谱就是一种「树形结构」。
引出问题 $  给定一棵 $n$ 个点，$m$ 条边，顶点编号为 $1\sim n$ 的无权树，$1$ 号节点为根。以 $i$ 号节点为根的子树有几个节点？
基本原理 $  $f[i]$ 表示以节点 $i$ 为根的子树大小，$Son(i)$ 表示 $i$ 的子节点集合。易知：
$$ f[i]=1+\sum_{v\in Son(i)}f[v] $$
$f[i]$ 由 $f[i$ 的子节点$]$ 推出，计算顺序应为 $f[$子节点$]→f[$父节点]。使用记忆化搜索。
vector&amp;lt;int&amp;gt; son[]; // son[u] : 节点 u 的子节点集合  void dfs(int u) { // 求以 u 为根的子树中节点个数  f[u] = 1; for(int i = 0; i &amp;lt; son[u].size(); i ++) { int v = son[u][i]; // 节点 u 的第 i 个子节点  dfs(v); f[u] += f[v]; } } 例题 $  没有上司的舞会 $  公司有 $n$ 个人（编号 $1\cdots n$），现要举⾏⼀场晚会，并规定如果邀请了某个⼈，那么⼀定不会邀请他的上司（他上司的上司，上司的上司的上司 $\cdots$ 都可以邀请）。</description>
    </item>
    
    <item>
      <title>线段树</title>
      <link>https://freeze.org.cn/docs/DS/segtree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://freeze.org.cn/docs/DS/segtree/</guid>
      <description>引入问题 $  数组 $A$ 中共 $n$ 个元素，对其反复进行以下操作共 $m$ 次：
  单点修改：将 $A[id]$ 修改为 $v$。
  区间查询：查询 $A[l\cdots r]$ 的最小值。
  区间修改：将 $A[l\cdots r]$ 每个数加上 $v$。
  int a[]; void set(int id, int v) { // 单点修改  a[id] = v; } int ask(int l, int r) { // 区间查询  int ans = 0; for(int i = l; i &amp;lt;= r; i ++) ans = min(ans, a[i]); return ans; } void add(int l, int r, int v) { // 区间修改  for(int i = l; i &amp;lt;= r; i ++) a[i] += v; }     暴力算法（$\textcolor{red}{×}$） 线段树（$\textcolor{green}{√}$）     单点修改 $\textcolor{green}{O(1)}$ $\textcolor{green}{O(\log{n})}$   区间查询 $\textcolor{red}{O(n)}$ $\textcolor{green}{O(\log{n})}$   区间修改 $\textcolor{red}{O(n)}$ $\textcolor{green}{O(\log{n})}$   $m$ 次操作 $\textcolor{red}{O(mn)}$ $\textcolor{green}{O(m\log{n})}$    构造 $  查询数组 $A={6,2,3,7,1,5,4,2}$ 中的最小值时，通常使用「两两比较法」：每次比较相邻两项，只保留更小的一项。比较的过程可以画成一棵二叉树，树根是答案。</description>
    </item>
    
  </channel>
</rss>
